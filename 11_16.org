* Racket第三课 - 12个Racket编程要点（下）

** 上节课 尾递归 知识更正

尾递归指一个函数所有递归形式的调用都出现在函数末尾，我们称这种递归为尾递归。

#+BEGIN_SRC racket
; 一种递归 空间效率差
(define
  factorial
  (λ (n)
    (if (= n 0)
	1
	(* n (factorial (- n 1))))))

;尾递归
(define fac (λ (n)
              (let loop ([i n]
                         [k 1])
                (if (= i 0)
                    k
                    (loop (- i 1) (* i k)))))
#+END_SRC

可以看到，第一种递归虽然在函数末尾调用，但是在调用中，函数处于运算中。
在这种情况下编译器不能够进行优化，导致递归仍然需要创建栈帧。

所以需要以直接调用的形式放在末尾，编译器才能够优化代码，在原有的栈帧空间执行。

** 编译原理知识补充

 *编译原理* 很重要。

编译原理有 *活动记录* 的概念，表示一个过程的一次执行所需信息的管理。

 *编译* 和 *解释* 都是做翻译。解释是一句一句翻译，但是编译像批处理。

从数据结构操作的算法来看，编译本质上是对符号表的增删改查的操作。

C语言和LISP语言不一样，除了语法和编译不同以外，关键是运行时系统不一样。

在运行时的系统中，程序有两部分：

- program 程序处理部分
- data 数据部分

在运行中，就有代码段和数据段。处理器每次接收一个时钟都向前运行一行代码。
在X86机器上，有个PC(IP)程序计数器指向代码的位置。




