* 课程简介

本次人工智能培训班讲课内容分为三大部分。

1. 计算的本质
2. Racket语言
3. AI方法论

* 第一课 计算的本质 & Racket第一课

时间：2016年11月14日

 *笔者注* ：本课基于离散数学、拓扑学、集合论、范畴学等领域知识归纳演绎得到，知识范围广、体量大，所以笔记中必有很多误解之处，望读者见谅。

** 计算的本质

我们将从数学、哲学、计算机三个角度来分析计算的本质。计算的本质在数学上分为六大关系：

1. 局整关系
2. 形影关系
3. 异同关系
4. 范序
5. 泛导
6. 泛极

*** 1 局整关系

通过集合论来表达关系。B属于A，那么B和A是局整关系。

*** 2 形影关系

指两个事物之间有关系，包括映射等都属于。笛卡尔坐标中(x,y)在X和Y轴的位置是典型的形影关系。

*** 3 异同关系

比如 /x ∈ seminar/ ,这个集合指：屋里的人都属于这个班。屋里的人和屋外的人有本质差异，这里存在隶属关系。

屋里的人和屋外的人是异同关系，这种 *异同关系产生了类型* ，屋里的人和屋外的人是不同的类型。

*** 4 泛序

泛序是指广义的排序。泛序分为三类：

1. 偏序
2. 全序
3. 良序

偏序指：某一部分可以找到某种排序关系。

全序指：所有元素有序。

良序指：有序元素的全序集合。

*** 5 泛导

泛导指广义的导数。广义上两个量在一起做比类叫泛导。泛导是从微积分中推广得到的概念。

*** 6 泛极

泛极是极限的推广，我们学过的收敛是其中的一种情况。包含以下几种状态：

- 奇 两个量的类型不一样，则不能表达。
- 混 混沌是一种常态，难以找到答案。
- 正常 比如：收敛。正指在一定范围内，常指度量、结果是常数。

*** 什么是关系？

关系是直积空间（DIRECT PRODUCT）的子集。

比如： /A {a1, a2, a3 ...}/ , /B {b1, b2, b3 ...}/ , /A*B/
 构成的新集合叫直积，如 /(a1, b1)/ 、 /(a1, b3)/ 。

形影关系、局整关系 => 通过运筹 => 得到关系的数学版本。

有了集合的基本概念，除了直积、还有差集、补集等才能够研究映射关系。

度量集合可以从以下几点：

1. 基数：元素的个数
2. 序数：排序
3. 纲：无穷中有粒度问题，第一纲（自然数），第二纲（连续统），就如连续统比自然数大。

还有代数系统部分。代数系统研究三元关系，两个元素运算得到一个新的元素。分为：

- 内部运算
- 外部运算

比如： /3x7=21/ 产生新的数 21 仍然属于自然数，这叫内部运算。外部运算则产生不属于原集合的数。
内部运算具有封闭性。从代数系统里研究得到律、环、群等，如：结合律、分配率。

*** 集合论

集合论内容有：

- 概念
- 谈论关系和映射
- 测度、考虑元素基数
- 考虑排序
- 格的理论
- 代数系统
- 泛序论

为了描述计算的本质，可转化为八则运算。
比如：交集是做减法，集合的乘法构造空间，除法：平面->投影->分量，并集->加法，从直积空间分解->集合。

利用这种等价关系进行等价聚类。等价关系是指满足：

1. 自反关系
2. 反对称
3. 传递性

这在数学中很重要。

*** ICBE 理论

从集合出发可以发展出 *ICBE* 理论。

- I：INTER 内部
- E：EXTERNAL 外部
- C：CLOSURE 导集
- B：BOUNDARY 边界

导集 => 闭包：无论系统如何扩大都在内部

哲学有本体论、存在论等。

在拓扑空间 T 中有几个定理：

- 定理1：空集 ∅ 是一个元素
- 定理2：A集合视为一个元素
- 定理3：集合内部空集的点构成的子集是一个元素
- 定理4： T 与内部子集做加法仍然是 T

用拓扑学知识来研究数学，前提就是有存在性。

有存在性，拓扑结构一定有个边界 => 异同关系。
边界产生抽象屏障（ABSTRACT BARRIER），比如LAMBDA表达式就是一个闭包，就是一个抽象屏障。

** Racket语言

*** 定义一个函数

Racket属于LISP的一种实现。在LISP中定义一个函数名 foo ，并使用 lambda 定义一个表达式：

#+BEGIN_SRC racket
(lambda ()
   "HELLO WORLD")
#+END_SRC

定义 foo 函数的完整语句如下：

#+BEGIN_SRC racket
(define
  foo
    (lambda ()
    "HELLO WORLD"))
#+END_SRC

这实际上就是一个闭包。

*** 运算

=(foo)= 把 foo 放入表达式运算

=(lamdba () "Hello world")= 结果： =“Hello world”=

=(lambda display "Hello world")= 结果： =hello world=

 LISP 语言中没有赋值，当语言中有赋值操作就需要关注寄存器的状态。

*** 列表

 LISP 中的列表:

#+BEGIN_SRC emacs-lisp
'(1 2 3 4 5)
#+END_SRC

输入'(foo)则会打印'(foo),因为加上'(...)则是数据。

*** 函数

**** 第一等对象

在LISP中，函数是第一等对象。

第一等对象指：

1. 可以被返回
2. 可以被传递
3. 可以被重命名，被调用。

比如在C语言中，函数不是第一等对象，因为函数不能被传递，但是函数指针可以。

函数举例：

#+BEGIN_SRC emacs-lisp
; squre函数
(define square
  (λ (x)
    (* x x)))

; cubic函数
(define cubic
  (λ (x)
    (* (square x) x)))

; c2函数
(define c2
  (λ (foo x)
    (* (foo x) x)))

; 函数可以被返回
(λ ()
  (λ ()
    "Hello world"))

; 该函数构造数据:偶对 '(1.2)
(cons 1 2)

;结果：'(1 (2.3))
(cons 1 (cons 2 3))
#+END_SRC

**** 应用序 正则序

- 应用序：如 (Racket)Lisp
- 正则序：先化简后运算，如：Haskell => Lasy求值（惰性求值）


**** car cdr

#+BEGIN_SRC emacs-lisp
; 结果 1
(car '(1.2))

; 结果 2
(cdr '(1,2))
#+END_SRC

car 函数取出第一个数， cdr 函数去除第一个数，取出后面的数。

**** ‘()

'() 代表空表，列表最后一个元素都为空。如：'(1 2 3 4 5 '())。

'(2 '(3 4) 5) 是嵌套列表。



*** 宏

LISP可以定义自己的宏（marco），所以适合做DSL（领域专用语言）和编译器。

*** 可计算函数构造方法

1. 前继函数
2. 后续函数
3. 测零函数
4. 不动点函数

从数理逻辑角度程序需要这四类函数。

*** 搜索举例

列表元素搜索从外到内一层一层找。

#+BEGIN_SRC emacs-lisp
#lang racket

(define search
  (lambda (l x)
    (cond
      [(null? l) 'not_found]
      [(= x (car l)) 'found]
      [else (search (cdr l) x)])))
(search '(1 2 3 4 5))
#+END_SRC

