<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>1week</title>
<!-- 2016-11-23 三 19:21 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="hexingpeng" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">1week</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 课程简介</a></li>
<li><a href="#sec-2">2. 第一课 计算的本质 &amp; Racket第一课</a>
<ul>
<li><a href="#sec-2-1">2.1. 计算的本质</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. 1 局整关系</a></li>
<li><a href="#sec-2-1-2">2.1.2. 2 形影关系</a></li>
<li><a href="#sec-2-1-3">2.1.3. 3 异同关系</a></li>
<li><a href="#sec-2-1-4">2.1.4. 4 泛序</a></li>
<li><a href="#sec-2-1-5">2.1.5. 5 泛导</a></li>
<li><a href="#sec-2-1-6">2.1.6. 6 泛极</a></li>
<li><a href="#sec-2-1-7">2.1.7. 什么是关系？</a></li>
<li><a href="#sec-2-1-8">2.1.8. 集合论</a></li>
<li><a href="#sec-2-1-9">2.1.9. ICBE 理论</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. Racket语言</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. 定义一个函数</a></li>
<li><a href="#sec-2-2-2">2.2.2. 运算</a></li>
<li><a href="#sec-2-2-3">2.2.3. 列表</a></li>
<li><a href="#sec-2-2-4">2.2.4. 函数</a></li>
<li><a href="#sec-2-2-5">2.2.5. 宏</a></li>
<li><a href="#sec-2-2-6">2.2.6. 可计算函数构造方法</a></li>
<li><a href="#sec-2-2-7">2.2.7. 搜索举例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Racket第二课 &#x2013; 12个Racket编程要点（上）</a>
<ul>
<li><a href="#sec-3-1">3.1. 要点总览</a></li>
<li><a href="#sec-3-2">3.2. 1. λ-excp</a></li>
<li><a href="#sec-3-3">3.3. 2. INTERNAL DEFINITION</a></li>
<li><a href="#sec-3-4">3.4. 3. SYMBOLIC TABLE</a></li>
<li><a href="#sec-3-5">3.5. 4. FRIST-CLASS OBJECT</a></li>
<li><a href="#sec-3-6">3.6. 5. DISPATCH FUNCTION</a></li>
<li><a href="#sec-3-7">3.7. 6. LET SPECIAL FORM</a></li>
<li><a href="#sec-3-8">3.8. 7. LETREC</a></li>
<li><a href="#sec-3-9">3.9. 8. NAMED LOOP</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Racket第三课 - 12个Racket编程要点（下）</a>
<ul>
<li><a href="#sec-4-1">4.1. 上节课 尾递归 知识更正</a></li>
<li><a href="#sec-4-2">4.2. 编译原理知识补充</a>
<ul>
<li><a href="#sec-4-2-1">4.2.1. 运行时系统</a></li>
<li><a href="#sec-4-2-2">4.2.2. 堆栈（栈）</a></li>
<li><a href="#sec-4-2-3">4.2.3. 附加段（堆）</a></li>
<li><a href="#sec-4-2-4">4.2.4. 栈框</a></li>
</ul>
</li>
<li><a href="#sec-4-3">4.3. 9 LIST PROCESS FUNCTIONS</a></li>
<li><a href="#sec-4-4">4.4. 10 DATABASE</a>
<ul>
<li><a href="#sec-4-4-1">4.4.1. 列表、偶对的结构</a></li>
</ul>
</li>
<li><a href="#sec-4-5">4.5. 11 QUASI-QUOTATION</a></li>
<li><a href="#sec-4-6">4.6. 12 EVALUATOR(REPL)</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Racket第四课</a>
<ul>
<li><a href="#sec-5-1">5.1. 复习昨天的内容</a></li>
<li><a href="#sec-5-2">5.2. 求值器第二课</a></li>
<li><a href="#sec-5-3">5.3. call/cc 函数</a></li>
<li><a href="#sec-5-4">5.4. PROMISE</a></li>
<li><a href="#sec-5-5">5.5. 求值器的变形</a>
<ul>
<li><a href="#sec-5-5-1">5.5.1. STREAM</a></li>
<li><a href="#sec-5-5-2">5.5.2. AMB</a></li>
<li><a href="#sec-5-5-3">5.5.3. LOGIC PROGRAMMING</a></li>
</ul>
</li>
<li><a href="#sec-5-6">5.6. 泛系方法论</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Racket 第五课</a>
<ul>
<li><a href="#sec-6-1">6.1. 昨日复习</a></li>
<li><a href="#sec-6-2">6.2. 人工智能导论</a>
<ul>
<li><a href="#sec-6-2-1">6.2.1. 一 AI 简介</a></li>
<li><a href="#sec-6-2-2">6.2.2. 二 AI ETHODOCOGY</a></li>
<li><a href="#sec-6-2-3">6.2.3. 三 LISP与AI的关系</a></li>
<li><a href="#sec-6-2-4">6.2.4. 四 CAE STUDIES</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 课程简介</h2>
<div class="outline-text-2" id="text-1">
<p>
本次人工智能培训班讲课内容分为三大部分。
</p>

<ol class="org-ol">
<li>计算的本质
</li>
<li>Racket语言
</li>
<li>AI方法论
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 第一课 计算的本质 &amp; Racket第一课</h2>
<div class="outline-text-2" id="text-2">
<p>
时间：2016年11月14日
</p>

<p>
<b>笔者注</b> ：本课基于离散数学、拓扑学、集合论、范畴学等领域知识归纳演绎得到，知识范围广、体量大，所以笔记中必有很多误解之处，望读者见谅。
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 计算的本质</h3>
<div class="outline-text-3" id="text-2-1">
<p>
我们将从数学、哲学、计算机三个角度来分析计算的本质。计算的本质在数学上分为六大关系：
</p>

<ol class="org-ol">
<li>局整关系
</li>
<li>形影关系
</li>
<li>异同关系
</li>
<li>范序
</li>
<li>泛导
</li>
<li>泛极
</li>
</ol>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> 1 局整关系</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
通过集合论来表达关系。B属于A，那么B和A是局整关系。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> 2 形影关系</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
指两个事物之间有关系，包括映射等都属于。笛卡尔坐标中(x,y)在X和Y轴的位置是典型的形影关系。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> 3 异同关系</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
比如 <i>x ∈ seminar</i> ,这个集合指：屋里的人都属于这个班。屋里的人和屋外的人有本质差异，这里存在隶属关系。
</p>

<p>
屋里的人和屋外的人是异同关系，这种 <b>异同关系产生了类型</b> ，屋里的人和屋外的人是不同的类型。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4"><span class="section-number-4">2.1.4</span> 4 泛序</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
泛序是指广义的排序。泛序分为三类：
</p>

<ol class="org-ol">
<li>偏序
</li>
<li>全序
</li>
<li>良序
</li>
</ol>

<p>
偏序指：某一部分可以找到某种排序关系。
</p>

<p>
全序指：所有元素有序。
</p>

<p>
良序指：有序元素的全序集合。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-5" class="outline-4">
<h4 id="sec-2-1-5"><span class="section-number-4">2.1.5</span> 5 泛导</h4>
<div class="outline-text-4" id="text-2-1-5">
<p>
泛导指广义的导数。广义上两个量在一起做比类叫泛导。泛导是从微积分中推广得到的概念。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-6" class="outline-4">
<h4 id="sec-2-1-6"><span class="section-number-4">2.1.6</span> 6 泛极</h4>
<div class="outline-text-4" id="text-2-1-6">
<p>
泛极是极限的推广，我们学过的收敛是其中的一种情况。包含以下几种状态：
</p>

<ul class="org-ul">
<li>奇 两个量的类型不一样，则不能表达。
</li>
<li>混 混沌是一种常态，难以找到答案。
</li>
<li>正常 比如：收敛。正指在一定范围内，常指度量、结果是常数。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-1-7" class="outline-4">
<h4 id="sec-2-1-7"><span class="section-number-4">2.1.7</span> 什么是关系？</h4>
<div class="outline-text-4" id="text-2-1-7">
<p>
关系是直积空间（DIRECT PRODUCT）的子集。
</p>

<p>
比如： <i>A {a1, a2, a3 &#x2026;}</i> , <i>B {b1, b2, b3 &#x2026;}</i> , <i>A*B</i>
 构成的新集合叫直积，如 <i>(a1, b1)</i> 、 <i>(a1, b3)</i> 。
</p>

<p>
形影关系、局整关系 =&gt; 通过运筹 =&gt; 得到关系的数学版本。
</p>

<p>
有了集合的基本概念，除了直积、还有差集、补集等才能够研究映射关系。
</p>

<p>
度量集合可以从以下几点：
</p>

<ol class="org-ol">
<li>基数：元素的个数
</li>
<li>序数：排序
</li>
<li>纲：无穷中有粒度问题，第一纲（自然数），第二纲（连续统），就如连续统比自然数大。
</li>
</ol>

<p>
还有代数系统部分。代数系统研究三元关系，两个元素运算得到一个新的元素。分为：
</p>

<ul class="org-ul">
<li>内部运算
</li>
<li>外部运算
</li>
</ul>

<p>
比如： <i>3x7=21</i> 产生新的数 21 仍然属于自然数，这叫内部运算。外部运算则产生不属于原集合的数。
内部运算具有封闭性。从代数系统里研究得到律、环、群等，如：结合律、分配率。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-8" class="outline-4">
<h4 id="sec-2-1-8"><span class="section-number-4">2.1.8</span> 集合论</h4>
<div class="outline-text-4" id="text-2-1-8">
<p>
集合论内容有：
</p>

<ul class="org-ul">
<li>概念
</li>
<li>谈论关系和映射
</li>
<li>测度、考虑元素基数
</li>
<li>考虑排序
</li>
<li>格的理论
</li>
<li>代数系统
</li>
<li>泛序论
</li>
</ul>

<p>
为了描述计算的本质，可转化为八则运算。
比如：交集是做减法，集合的乘法构造空间，除法：平面-&gt;投影-&gt;分量，并集-&gt;加法，从直积空间分解-&gt;集合。
</p>

<p>
利用这种等价关系进行等价聚类。等价关系是指满足：
</p>

<ol class="org-ol">
<li>自反关系
</li>
<li>反对称
</li>
<li>传递性
</li>
</ol>

<p>
这在数学中很重要。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-9" class="outline-4">
<h4 id="sec-2-1-9"><span class="section-number-4">2.1.9</span> ICBE 理论</h4>
<div class="outline-text-4" id="text-2-1-9">
<p>
从集合出发可以发展出 <b>ICBE</b> 理论。
</p>

<ul class="org-ul">
<li>I：INTER 内部
</li>
<li>E：EXTERNAL 外部
</li>
<li>C：CLOSURE 导集
</li>
<li>B：BOUNDARY 边界
</li>
</ul>

<p>
导集 =&gt; 闭包：无论系统如何扩大都在内部
</p>

<p>
哲学有本体论、存在论等。
</p>

<p>
在拓扑空间 T 中有几个定理：
</p>

<ul class="org-ul">
<li>定理1：空集 ∅ 是一个元素
</li>
<li>定理2：A集合视为一个元素
</li>
<li>定理3：集合内部空集的点构成的子集是一个元素
</li>
<li>定理4： T 与内部子集做加法仍然是 T
</li>
</ul>

<p>
用拓扑学知识来研究数学，前提就是有存在性。
</p>

<p>
有存在性，拓扑结构一定有个边界 =&gt; 异同关系。
边界产生抽象屏障（ABSTRACT BARRIER），比如LAMBDA表达式就是一个闭包，就是一个抽象屏障。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Racket语言</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 定义一个函数</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Racket属于LISP的一种实现。在LISP中定义一个函数名 foo ，并使用 lambda 定义一个表达式：
</p>

<div class="org-src-container">

<pre class="src src-racket">(lambda ()
   "HELLO WORLD")
</pre>
</div>

<p>
定义 foo 函数的完整语句如下：
</p>

<div class="org-src-container">

<pre class="src src-racket">(define
  foo
    (lambda ()
    "HELLO WORLD"))
</pre>
</div>

<p>
这实际上就是一个闭包。
</p>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 运算</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
<code>(foo)</code> 把 foo 放入表达式运算
</p>

<p>
<code>(lamdba () "Hello world")</code> 结果： <code>“Hello world”</code>
</p>

<p>
<code>(lambda display "Hello world")</code> 结果： <code>hello world</code>
</p>

<p>
LISP 语言中没有赋值，当语言中有赋值操作就需要关注寄存器的状态。
</p>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> 列表</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
LISP 中的列表:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">'(1 2 3 4 5)
</pre>
</div>

<p>
输入'(foo)则会打印'(foo),因为加上'(&#x2026;)则是数据。
</p>
</div>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> 函数</h4>
<div class="outline-text-4" id="text-2-2-4">
</div><ol class="org-ol"><li><a id="sec-2-2-4-1" name="sec-2-2-4-1"></a>第一等对象<br  /><div class="outline-text-5" id="text-2-2-4-1">
<p>
在LISP中，函数是第一等对象。
</p>

<p>
第一等对象指：
</p>

<ol class="org-ol">
<li>可以被返回
</li>
<li>可以被传递
</li>
<li>可以被重命名，被调用。
</li>
</ol>

<p>
比如在C语言中，函数不是第一等对象，因为函数不能被传递，但是函数指针可以。
</p>

<p>
函数举例：
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">; squre函数
(define square
  (λ (x)
    (* x x)))

; cubic函数
(define cubic
  (λ (x)
    (* (square x) x)))

; c2函数
(define c2
  (λ (foo x)
    (* (foo x) x)))

; 函数可以被返回
(λ ()
  (λ ()
    "Hello world"))

; 该函数构造数据:偶对 '(1.2)
(cons 1 2)

;结果：'(1 (2.3))
(cons 1 (cons 2 3))
</pre>
</div>
</div>
</li>

<li><a id="sec-2-2-4-2" name="sec-2-2-4-2"></a>应用序 正则序<br  /><div class="outline-text-5" id="text-2-2-4-2">
<ul class="org-ul">
<li>应用序：如 (Racket)Lisp
</li>
<li>正则序：先化简后运算，如：Haskell =&gt; Lasy求值（惰性求值）
</li>
</ul>
</div>
</li>


<li><a id="sec-2-2-4-3" name="sec-2-2-4-3"></a>car cdr<br  /><div class="outline-text-5" id="text-2-2-4-3">
<div class="org-src-container">

<pre class="src src-emacs-lisp">; 结果 1
(car '(1.2))

; 结果 2
(cdr '(1,2))
</pre>
</div>

<p>
car 函数取出第一个数， cdr 函数去除第一个数，取出后面的数。
</p>
</div>
</li>

<li><a id="sec-2-2-4-4" name="sec-2-2-4-4"></a>‘()<br  /><div class="outline-text-5" id="text-2-2-4-4">
<p>
'() 代表空表，列表最后一个元素都为空。如：'(1 2 3 4 5 '())。
</p>

<p>
'(2 '(3 4) 5) 是嵌套列表。
</p>
</div>
</li></ol>
</div>



<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> 宏</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
LISP可以定义自己的宏（marco），所以适合做DSL（领域专用语言）和编译器。
</p>
</div>
</div>

<div id="outline-container-sec-2-2-6" class="outline-4">
<h4 id="sec-2-2-6"><span class="section-number-4">2.2.6</span> 可计算函数构造方法</h4>
<div class="outline-text-4" id="text-2-2-6">
<ol class="org-ol">
<li>前继函数
</li>
<li>后续函数
</li>
<li>测零函数
</li>
<li>不动点函数
</li>
</ol>

<p>
从数理逻辑角度程序需要这四类函数。
</p>
</div>
</div>

<div id="outline-container-sec-2-2-7" class="outline-4">
<h4 id="sec-2-2-7"><span class="section-number-4">2.2.7</span> 搜索举例</h4>
<div class="outline-text-4" id="text-2-2-7">
<p>
列表元素搜索从外到内一层一层找。
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">#lang racket

(define search
  (lambda (l x)
    (cond
      [(null? l) 'not_found]
      [(= x (car l)) 'found]
      [else (search (cdr l) x)])))
(search '(1 2 3 4 5))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Racket第二课 &#x2013; 12个Racket编程要点（上）</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 要点总览</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li>λ-excp （lambda表达式）
</li>
<li>INTERNAL DEFINITION （内部定义）
</li>
<li>SYMBOLIC TABLE （符号表）
</li>
<li>FRIST-CLASS OBJECT （函数属于第一等对象）
</li>
<li>DISPATCH FUNCTION （发派函数）
</li>
<li>LET SPECIAL FORM (嵌套闭包)
</li>
<li>LETREC （相互调用）
</li>
<li>NAMED LOOP (尾递归 TAIL-RECURSION)
</li>
<li>LIST PROCESS FUNCTIONS （关联列表 alist，链表 assoc）
</li>
<li>DATABASE (用派发函数 DISPATCH FUNC 操作数据库)
</li>
<li>QUASI-QUOTATION (准引用)
</li>
<li>EVALUATOR(REPL) (高阶算子 HIGHER ORDER OPERATOR)
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 1. λ-excp</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Lambda表达式缩写为λ，lambda表达式就是一个闭包。
</p>

<p>
<b>THUNK</b> ：我们把lambda表达式没有参数这种情况叫做 THUNK ，译作悟空。
</p>

<div class="org-src-container">

<pre class="src src-racket">比如函数
  (λ ()    ;没有参数
    (* 100 100))
</pre>
</div>

<p>
闭包的特性：只有一个口可以进去，参数也通过此传入进去。
</p>

<p>
表达式参数有三种写法。
</p>

<ul class="org-ul">
<li>λ (x y) 两个或多个参数
</li>
<li>λ (x . y) 左边一部分是确定的，如：(x y . z)。后面的会被当做列表
</li>
<li>λ (x) 参数个数不限，会合并成一个列表传入
</li>
</ul>

<p>
示例如下：
</p>
<div class="org-src-container">

<pre class="src src-racket">#lang racket

(define f2 (λ (x . y) (displayln x)))
;结果 1
(f2 1 2 3 4 5)
; (1 2 3)
(f2 '(1 2 3))
; 1
(f2 1 2 3)

(define f3 (λ (x . y) (displayln (car y))))
; 2
(f3 1 2 3)

(define f4 (λ (x . y) (displayln (cdr y))))
; (3)
(f4 1 2 3)

(define f5 (λ (x . y) (displayln (cadr y))))
; 3
(f5 1 2 3 4 5)

(define f6 (λ (x . y) (displayln (cddr y))))
; (4 5)
(f6 1 2 3 4 5)

(define f7 (λ (x . y) (displayln (car x))))
; 1
(f7 '(1 2) 2 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 2. INTERNAL DEFINITION</h3>
<div class="outline-text-3" id="text-3-3">
<p>
内部定义相当于在内部定义一个宪法，在外部用不了。
</p>

<div class="org-src-container">

<pre class="src src-racket">#lang racket

(λ ()
  (define c (λ (x)
	      (* x x)))
  c) ；返回内部函数c

(define foo (lambda () (define f (λ (x) (* x x))) f))

((foo) 4)
</pre>
</div>

<p>
在lambda里定义函数必须在使用该函数之前。
</p>

<p>
函数在LISP中是第一等对象，可被直接返回，另外利用 <code>valus</code> 可以返回多个。
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 3. SYMBOLIC TABLE</h3>
<div class="outline-text-3" id="text-3-4">
<p>
<b>符号表</b> 就如同表格，记录每个对象。 <b>在学习编程语言时一定要建立起符号表的概念，非常重要</b> 。
</p>

<p>
在老的LISP里有如下5个字段：
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">字段</th>
<th scope="col" class="left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">name</td>
<td class="left">名称</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">type</td>
<td class="left">类型</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">value</td>
<td class="left">值</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">plist</td>
<td class="left">有哪些proprity（属性）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">lambda</td>
<td class="left">λ表达式</td>
</tr>
</tbody>
</table>

<p>
在后来的 scheme 中，没有了 <code>plist</code> 字段，以及 <code>value</code> 和 <code>lamdba</code> 字段合并在一起。
</p>

<p>
在LISP有很多谓词（predicator），如： <code>(number? 100)</code> 。
可以用这些谓词查询类型，就是通过查询符号表 <i>type</i> 。
可以做合同，约定类型，都和字符表有关。
</p>

<p>
<i>name</i> 和 <i>lambda</i> 是形影关系，绑定（bound）在一起。
</p>

<p>
<code>define</code> 的本质是建立偶对，每次 <code>define</code> 都在字符表中插入一条记录，若相同的名称定义了第二次，则会删除原记录，新建一个记录。
</p>

<p>
LISP中有垃圾回收机制，会回收不用的数据。
</p>

<p>
符号表是计算机科学的中心数据结构。
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> 4. FRIST-CLASS OBJECT</h3>
<div class="outline-text-3" id="text-3-5">
<p>
第一等对象指：
</p>

<ul class="org-ul">
<li>可以被返回。
</li>
<li>可以被传递。
</li>
<li>可以被命名，作为一个单独的条目存在符号表中。
</li>
<li>可以和其他类型构成数据结构。
</li>
</ul>

<p>
LISP中的函数是第一等对象。
</p>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 5. DISPATCH FUNCTION</h3>
<div class="outline-text-3" id="text-3-6">
<p>
发派函数的核心思想是： <b>对外扫相、对内破执</b> 。
</p>

<p>
意思是从外部提供相应的符号，拿到闭包内用对于的函数做相应的计算。
</p>

<p>
这种方式属于数据提供的编程。
</p>


<p>
比如：
</p>
<div class="org-src-container">

<pre class="src src-racket">#lang racket

;定义发派函数
(define foo
  (λ (s)
  (define (f1) (displayln 'present-flower))
  (define (f2) (displayln 'provide-money))
  (define d (lambda ()
  (cond
    [(equal? s 'beautilful) (f1)]
    [(equal? s 'poor) (f2)])))
  d))

;使用
((foo 'poor))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> 6. LET SPECIAL FORM</h3>
<div class="outline-text-3" id="text-3-7">
<p>
匿名表达式（anonymous）通过 <code>define</code> 操作变成有名函数（named）。
</p>

<div class="org-src-container">

<pre class="src src-racket">; 例1：匿名表达式
((λ (x y)
   (* x y))
 100
 200)

; 例2：通过let绑定多个对象
(let ((x 100)
      (y 200))
      (* x y))

; 例3：嵌套使用
(let ((x 100)
      (y 200))
  (let ((z 300))
    (* x y z)))

; 例4：使用let* 互相绑定，则无需嵌套
(let* ((x 1)
       (y 2)
       (z (* x y)))
  (* x y z))
</pre>
</div>

<p>
<b>注意</b> ：就如 例3 所示，两个闭包嵌套使用。在外层的闭包只可以使用内层的对象，如例子中的z。
但是对于处于同一层次的对象 x y 则不能相互调用，如果x的绑定中用到了y则是错误的。
</p>

<p>
这时可以使用 <code>let*</code> 避免嵌套，如 例4 所示，这时一种语法糖（句法糖）。
</p>
</div>
</div>

<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> 7. LETREC</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">

<pre class="src src-racket">(define is-even?
  (λ (x)
    (if (= x 0)
	#t
	(is-odd? (- x 1)))))
(define is-odd?
  (λ (x)
    (if (= x 0)
	#f
	(is-even? (- x 1)))))

(is-even? 100)
(is-even? 101)
(is-odd? 9)
</pre>
</div>

<p>
上例为计算是否为偶数和奇数的两个函数，两个函数有相互调用的关系。
我们可以不用一个一个定义两个函数，可以结合在一起同时定义。
</p>

<p>
可以使用 <code>letrec</code> ，如下所示：
</p>
<div class="org-src-container">

<pre class="src src-racket">(letrec ((is-even?
	  (λ (x)
	    (if (= x 0)
		#t
		(is-odd? (- x 1)))))
	 (is-odd?
	  (λ (x)
	    (if (= x 0)
		#f
		(is-even? (- x 1))))))
  (is-even? 100)
  (is-even? 101))
</pre>
</div>

<p>
这里面任意闭包都可以相互调用。
</p>
</div>
</div>

<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> 8. NAMED LOOP</h3>
<div class="outline-text-3" id="text-3-9">
<p>
下例展示一种常规的递归方法。
</p>
<div class="org-src-container">

<pre class="src src-racket">; 一种递归 空间效率差
(define
  factorial
  (λ (n)
    (if (= n 0)
	1
	(* n (factorial (- n 1))))))

(factorial 5)
</pre>
</div>

<p>
上例中的递归由于需要嵌套的调用函数，虽然逻辑清晰，但是会导致空间效率特别差。
</p>

<p>
我们可以使用尾递归，在恒定的空间内部运算，没有空间效率损失。
如下例所示，就是尾递归的写法。
</p>

<p>
使用 <code>let</code> 来绑定函数，在内部调用该函数时会回到之前所在位置执行，个人理解类似C语言中的 <code>goto</code> 。
</p>

<div class="org-src-container">

<pre class="src src-racket">;尾递归
(define fac (λ (n)
	      (let loop ([i n]
			 [k 1])
		(if (= i 0)
		    k
		    (loop (- i 1) (* i k))))))
(fac 4)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Racket第三课 - 12个Racket编程要点（下）</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 上节课 尾递归 知识更正</h3>
<div class="outline-text-3" id="text-4-1">
<p>
尾递归指一个函数所有递归形式的调用都出现在函数末尾，我们称这种递归为尾递归。
</p>

<div class="org-src-container">

<pre class="src src-racket">; 一种递归 空间效率差
(define
  factorial
  (λ (n)
    (if (= n 0)
	1
	(* n (factorial (- n 1))))))

;尾递归
(define fac (λ (n)
	      (let loop ([i n]
			 [k 1])
		(if (= i 0)
		    k
		    (loop (- i 1) (* i k)))))
</pre>
</div>

<p>
可以看到，第一种递归虽然在函数末尾调用，但是在调用中，函数处于运算中。
在这种情况下编译器不能够进行优化，导致递归仍然需要创建栈帧。
</p>

<p>
所以需要以直接调用的形式放在末尾，编译器才能够优化代码，在原有的栈帧空间执行。
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 编译原理知识补充</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<b>编译原理</b> 很重要。
</p>

<p>
编译原理有 <b>活动记录</b> 的概念，表示一个过程的一次执行所需信息的管理。
</p>

<p>
<b>编译</b> 和 <b>解释</b> 都是做翻译。解释是一句一句翻译，但是编译像批处理。
</p>

<p>
从数据结构操作的算法来看，编译本质上是对符号表的增删改查的操作。
</p>

<p>
C语言和LISP语言不一样，除了语法和编译不同以外，关键是运行时系统不一样。
</p>
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> 运行时系统</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
在运行时的系统中，程序有两部分：
</p>

<ul class="org-ul">
<li>program 程序处理部分 =&gt; CS
</li>
<li>data 数据部分 =&gt; DS DI SI
</li>
</ul>

<p>
在运行中，就有代码段和数据段。处理器每次接收一个时钟都向前运行一行代码。
在X86机器上，有个PC(IP)程序计数器指向代码的位置。
</p>

<p>
由程序处理部分引出CS寄存器，代码段地址寄存器。
</p>

<p>
由数据部分引出DS数据段段寄存器，DI目的变址寄存器，SI源变址寄存器。
DS做中转，DI指示写到那里去，SI指示数据从哪读取进来。
</p>

<p>
早期的FORTRAN语言只要这几个寄存器就够了。
</p>
</div>
</div>

<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> 堆栈（栈）</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
后来C、ALGOL等引入了堆栈（栈）的思想。
</p>

<pre class="example">
|   .    |  &lt;-- SS
|   .    |
|        |
|--------|  &lt;-- BP
| .....  |
| .....  |  &lt;-- SP
| .....  |
|--------|
|        |
|   .    |
|   .    |
|        |
</pre>

<p>
SS寄存器指向堆栈的起始地址，BP寄存器指向框的起点（栈帧的起点），SP堆栈指针指向所需位置，
</p>

<p>
但是堆栈（栈）有个缺点，弹出就没有了，所以引出了堆的概念。
</p>
</div>
</div>

<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3"><span class="section-number-4">4.2.3</span> 附加段（堆）</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
堆（HEAP）引出了ES寄存器，用来操作内存空间。
内存空间可以分为代码段、数据段、堆栈段、附加段三个部分。
</p>

<p>
为了更加方便的操作，引出了AX、BX、CX、DX四个通用寄存器。
</p>


<p>
加上用于存储计算机状态的Flag标志位寄存器，在8086 CPU上一共有14个寄存器。
</p>

<ul class="org-ul">
<li>4个数据寄存器(AX、BX、CX和DX)
</li>
<li>2个变址和指针寄存器(SI和DI)
</li>
<li>2个指针寄存器(SP和BP)
</li>
<li>4个段寄存器(CS、SS、DS、ES)
</li>
<li>1个指令指针寄存器(IP)
</li>
<li>1个标志寄存器(EFlags)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2-4" class="outline-4">
<h4 id="sec-4-2-4"><span class="section-number-4">4.2.4</span> 栈框</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
栈框就是指栈帧，一个函数运行时的栈空间，栈帧也叫过程活动记录。
</p>

<p>
ALGOL语言把堆栈分为7个部分。
</p>

<pre class="example">
|   .    |
|   .    |
|        |
|--------|
|  IN    | &lt;- 输入数据
|--------|
|  OUT   | &lt;- 输出数据
|--------|
| LOCAL  | &lt;- 局部变量
|--------|
| TEMP   | &lt;- 中间结果
|--------|
| SAVED  | &lt;- 保存的机器状态
|--------|
| DATA   | &lt;- 数据链
|--------|
| FUNC   | &lt;- 函数（动态）链
|--------|
|        |
|   .    |
|   .    |
|        |
</pre>

<p>
在C语言里，帧框中没有保留状态部分，没有数据链和函数链。
</p>

<p>
在SCHEME语言里，DATA和FUNC合二为一。
</p>

<p>
在尾递归中，帧框里的IN、OUT改变，不会增框。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 9 LIST PROCESS FUNCTIONS</h3>
<div class="outline-text-3" id="text-4-3">
<p>
LIST PROCESS FUNCTIONS 指列表处理函数。
</p>

<p>
Racket中有两种非常重要的数据类型，列表和偶对。
</p>

<p>
并且在Racket中，有一系列函数用于列表处理。如：
</p>

<ul class="org-ul">
<li>car cdar cddar
</li>
<li>cdr cadr
</li>
</ul>

<p>
car用于取出列表的第一个元素，cdr用于取出列表中除去第一个元素，后面的元素组成的新列表。
</p>

<p>
list函数用于创建列表。
</p>

<div class="org-src-container">

<pre class="src src-racket">; '(1 2 3 4 5 6)
(list 1 2 3 4 5 6)
</pre>
</div>

<p>
cons函数用于创造偶对。
</p>

<div class="org-src-container">

<pre class="src src-racket">; '(2 . 3)
(cons 2 3)

; '(2)
(cons 2 '())

; '(1 2 3)
(cons 1 '(2 3))
</pre>
</div>

<p>
一些列表处理函数示例：
</p>

<div class="org-src-container">

<pre class="src src-racket">; '(1 2 3 4)
(append '(1 2) '(3 4))

; '(3 2 1)
(reverse '(1 2 3))
</pre>
</div>

<p>
列表处理函数的原理都是对符号表进行操作。
</p>

<p>
完整的列表处理函数在安装Racket之后可以执行 <code>plt-help</code> 命令打开官方帮助文档查看。
</p>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 10 DATABASE</h3>
<div class="outline-text-3" id="text-4-4">
<p>
这个数据库指在Racket语言编程中，程序运行时，创建数据库。
</p>

<p>
在大型软件中，一个系统需要分解成模块来完成，使用模块化思想。这里有：
</p>

<ul class="org-ul">
<li>mechanism 机制 
</li>
<li>function 功能
</li>
</ul>

<p>
内部的机制和外在的功能一对概念。使用者不需要知道里面的机制，只需要知道功能。
</p>

<p>
内部的提供的机制通过数据库的形式组织起来。
</p>

<p>
在Racket中，数据库可以看做绑定（bound）的集合。
</p>

<p>
列表是最通用的容器，可以放很多的绑定（偶对）。 
</p>

<p>
在Racket有专门的列表，叫/alist/ （关联的列表），用来存放一个个偶对。
如： '((x . 200 (g . 200))) 。
</p>

<p>
可以看出来 <i>alist</i> 就是一个数据库。
</p>

<p>
可以使用派发函数来操作数据库，五种操作：
</p>

<ul class="org-ul">
<li>增 INSERT
</li>
<li>删 DELETE
</li>
<li>改 MULATE
</li>
<li>查 SEARCH
</li>
<li>排序 SORT
</li>
</ul>

<p>
有个 <code>assoc</code> 函数可以根据提供的标识符在 <i>alist</i> 中查找偶对。
</p>

<div class="org-src-container">

<pre class="src src-racket">(define lst '((x 100) (y 100) (z (lambda () (* 10 10)))))
; '(x 100)
(assoc 'x lst)
</pre>
</div>
</div>

<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1"><span class="section-number-4">4.4.1</span> 列表、偶对的结构</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
在LISP中，列表是偶对的嵌套。
计算的本质六大关系中的 泛导 -&gt; 偶对，泛极 -&gt; 测零。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (list 1 2 3)
'(1 2 3)
&gt; (cons 1 (cons 2 (cons 3 '())))
'(1 2 3)
&gt; (cons 1 '(2 3))
'(1 2 3)
&gt; (cons 1 (cons 2 3))
'(1 2 . 3)
</pre>
</div>

<p>
从上面四个语句创建的数据，可以看出来，前三个语句创建的列表完全相同，为 '(1 2 3)。
</p>

<p>
我们看一下这个列表 '(1 2 3) 在内存中的结构：
</p>

<div class="org-src-container">

<pre class="src src-racket">+---+---+      +---+---+      +---+---+
|   |   +----&gt; |   |   +----&gt; |   |   +---&gt; '()
+-+-+---+      +-+-+---+      +-+-+---+
  |              |              |
  +--&gt; 1         +--&gt; 2         +--&gt; 3
</pre>
</div>

<p>
而最后一个列表 '(1 2 . 3) 在内村中的结构如下：
</p>

<div class="org-src-container">

<pre class="src src-racket">+---+---+      +---+---+
|   |   +----&gt; |   |   +----&gt; 3
+-+-+---+      +-+-+---+
  |              |
  +--&gt; 1         +--&gt; 2
</pre>
</div>

<p>
所以列表是由一个个嵌套的偶对组成的，而最后一个偶对的值是 '() ，可以忽略不写。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> 11 QUASI-QUOTATION</h3>
<div class="outline-text-3" id="text-4-5">
<p>
准引用能够将算式里的值计算后输出，符号 <code>`</code> （ESC下面的按键），区别于单引号 ' 。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-racket">; 引用
'(1 2 3)

; 准引用
`(1 2 3)

; '(1 3 3)
`(1 ,(+ 1 2) 3)

; '(1 (2 3) 4)
`(1 ,(list 2 3) 4)

; '(1 (2 3) (list 4 5))
`(1 ,(list 2 3) (list 4 5))

; '(1 2 3 (list 4 5))
`(1 ,@(list 2 3) (list 4 5))
</pre>
</div>

<p>
准引用在宏（marco）中非常有用，用于符号计算。
</p>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> 12 EVALUATOR(REPL)</h3>
<div class="outline-text-3" id="text-4-6">
<p>
REPL指：
</p>
<ul class="org-ul">
<li>READ 读取表达式
</li>
<li>EVALUATE 对读取的表达式求值
</li>
<li>PRINT 把求值的结果打印出来
</li>
<li>LOOP 循环
</li>
</ul>

<p>
REPL就是LISP程序的基本流程。
</p>

<p>
求值的规则是LISP设计的关键，LISP核心是设计求值器。
说到求值的规则就回到了六大运算、八大规则。
</p>

<p>
求值器设计的核心就是 EVAL 函数： <b>(eval exp env)</b> 。
</p>

<p>
表达式的求值一定是在一个环境中，即 env 。
</p>

<p>
从哲学上来讲，对事物的评判一定是在一个限定的环境中，这是一个方法论，也是LISP的核心。
</p>

<p>
所以首先确定一个环境之后，再对需要的东西进行评估。
</p>

<p>
如何评判，首先看类型，比如：数字，偶对等，分类对策。
</p>

<p>
BNF范式就是用来定义类型系统的。
</p>

<p>
所以，在原有的派发函数基础上要加上一个环境，模型如图：
</p>
<pre class="example">
      eval
+--------------+  &lt;--- 外层环境
|     env      |
|   +-----+    |
|   | exp |    |
|   +-----+    |
|    (alist) &lt;-+--- 环境里有alist
+--------------+
</pre>

<p>
从闭包的角度，这就是两个闭包的嵌套。
</p>

<p>
环境里有个评判尺度，有alist存放数据，有增删改查排序5个操作，有cond函数分类对策，有派发函数来执行操作。
</p>

<p>
这就是LISP求值器设计的核心。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Racket第四课</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 复习昨天的内容</h3>
<div class="outline-text-3" id="text-5-1">
<p>
LISP 就是 LIST PROCESSOR ，说到了Alist、assoc函数、QUASI-QUOTATION。
</p>

<p>
REPL的R、P是I/O部分，核心是 EVALUATOR 求值器。
</p>

<p>
求值器模型： <i>(eval exp env )</i> ，首先根据类型分类对策， <i>env</i> 环境中的数据用alist存放，相当于数据库。
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 求值器第二课</h3>
<div class="outline-text-3" id="text-5-2">
<p>
把求值器展开更详细的说明，可以分为阴阳两部分。
在太极中阳代表动， <i>eval</i> 函数把表达式求值，则是阳的部分。
表达式的参数需要提前构造好，这个构造的过程是阴的过程。
求值器里使用 <i>(apply proc arg)</i> 函数来把参数 arg 传递给 proc 。
<i>apply</i> 执行的过程就是阴。
</p>

<p>
求值器是阴与阳的泛导，是不断的太极推手的过程，直到所有的复杂函数运算完毕。
</p>

<p>
在Racket的运行时系统中，光有堆不够用了。计算过程至少有4个参数：
</p>

<ul class="org-ul">
<li>exp
</li>
<li>env
</li>
<li>proc
</li>
<li>argc
</li>
</ul>

<p>
所以使用中，至少需要4个寄存器访问。
</p>

<ul class="org-ul">
<li>有一些中间计算结果 &#x2013;&gt; val寄存器
</li>
<li>未完成 -&gt; unev寄存器
</li>
<li>还有跳转记录程序过程 -&gt; continue寄存器
</li>
</ul>

<p>
所以一共7个寄存器 + 堆栈 =&gt; 才能完成求值过程。
</p>

<p>
在Racket语言的内存中，帧框（栈帧）不一定是连在一起的，所以需要continue寄存器连接下一个帧框。
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> call/cc 函数</h3>
<div class="outline-text-3" id="text-5-3">
<p>
continue（连续）对象可以被捕获，在LISP中，可以使用 <code>call/cc</code> 函数来捕获连续对象。
</p>

<p>
<code>call/cc</code> 全称为 call with current continuation 。
</p>

<p>
比如： <code>(+ (* 3 7) (/ 8 2))</code> 如果把 <code>(/8 2)</code> 算式换成未知的函数，并用点代替。
</p>

<p>
函数就只能计算到 <code>(+ 21 ·)</code> ，等待后面的值。或者若如 <code>(+ · 4)</code> 所示，前面未完成，后面已完成，在等待唤醒使用。
</p>

<p>
这就叫连续。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))
25
</pre>
</div>

<p>
可以看到，在上式中，我们用 <code>call/cc</code> 捕获了该连续，然后把 <code>(/ 8 2)</code> 传入 <code>k</code> ， <code>k</code> 就是捕获的连续。
这样 <code>(/ 8 2)</code> 就被代入未完成的函数继续计算，结果仍然为25。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (define foo 1)
&gt; (+ (* 3 7) (call/cc (lambda (k) (set! foo k) (/ 8 2))))
25
&gt; (foo 4)
25
</pre>
</div>

<p>
在上式中，我们把foo绑定为k，所以foo函数的内容就变成了上式的连续，传入4，就会计算 <code>(+ 21 4)</code> ,结果同样是25。
</p>

<p>
在易经中，有
</p>

<ul class="org-ul">
<li>既济
</li>
<li>未济
</li>
</ul>

<p>
两卦，既济是指已完成，未济是指未完成。可以对应到上面的连续。
</p>

<p>
在内存中，捕获连续就是把帧框（栈帧）取出来，包装成对象。
</p>

<p>
捕获连续有4种典型用法：
</p>

<ol class="org-ol">
<li>JUMP(ESCAPE) 跳转，比如跳转到指定堆栈中去给值计算
</li>
<li>CO-ROUTINES 协例程 指相互调用
</li>
<li>BACKTRACK 回溯
</li>
<li>ENGINE 发动机机制 油=&gt;数据驱动
</li>
</ol>

<div class="org-src-container">

<pre class="src src-racket">(define foo
  (λ (lst)
    (call/cc
     (λ (k)
       (cond
	 [(null? lst) 'no]
	 [(eq? (car lst) #f) (k #t)]
	 [else (foo (cdr lst))])))))
; 'no
(foo '(1 2 3 4))
; #t
(foo '(1 2 3 4 #f 5))
</pre>
</div>

<p>
上式中的call/cc 捕获了lambda表达式，调用 foo 函数时，需要注意程序的执行顺序。
在程序没有遇到 <code>(k #t)</code> ，即 <code>K</code> 的调用处时，函数是正常执行的。
所以在 foo 函数递归到 lst 里第一个元素是 #f 时，就会执行到 <code>(k #t)</code> ， <code>call/cc</code> 就会捕获当前这个连续。
</p>

<p>
当前的连续就是该lambda表达式，因此当前表达式就变成了 <code>#t</code> ，所以就会输出 <code>#t</code> 。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (call/cc (lambda (k) (displayln (+ 2 3) (k 'done))))
'done
&gt; (eval ''done)
'done
</pre>
</div>

<p>
上述例子演示了捕获最外层的 <code>eval</code> 函数，等价效果如执行第二个 <code>eval</code> 函数。
</p>

<p>
在LISP中，连续式第一等对象。
</p>

<p>
从C语言的角度看 <code>call/cc</code> 的实现，利用了 &lt;setjump.h&gt; 库里的功能。
主要有 jump<sub>buf</sub> 结构，用于存放现场数据， setjump() 保存现场， longjump() 恢复现场。
</p>

<p>
在LISP的运行时系统（RUN-TIMESYSTEM）中，符号表是自含的（SELF-CONTAINED）。
符号表保存在内存中，并且栈框在内存中是不连续的，这就保证了灵活性。
</p>

<pre class="example">
  +--------+
..|........|.. &lt;-- 保存现场
. |        | .
. +--------+ .
. | \ \ \ \| . &lt;-- STACK FRAME
. |\ \ \ \ | . &lt;- - 表达式：(* 3 7)
. | \ \ \ \| . &lt;-- 计算结果：21
. +--------+ .
. |        | .
. |        | .
. +--------+ .
. | xxxxxx | .
. | xxxxxx | . &lt;-- STACK FRAME
. | xxxxxx | . &lt;-- 捕获处，未计算
. +--------+ .
. |        | .
..|... ....|..
  |        |
</pre>

<p>
以捕获 <code>(+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))</code> 为例，
如上图所示，在内存中，各个表达式所在的栈框在内存中是不连续的，并且 <code>(* 3 7)</code> 会完成计算，
和其他必须的数据一同被拷贝下来，复制到lambda所在的栈框执行。除了已完成计算的部分，其他未计算的部分都会被丢弃。
</p>

<p>
即：call/cc 后面未计算的部分会被丢弃。
</p>

<p>
基于LISP的栈不连续，用自含的符号表查询栈的位置，非常灵活。
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> PROMISE</h3>
<div class="outline-text-3" id="text-5-4">
<p>
SCHEME 默认是应用序，会先把参数算出来。
可以改成正则序，需要的时候再算。
</p>

<p>
PROMISE（承诺）就能够延迟运算表达式，就像加了层衣服。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (delay (+ 1 100))
#&lt;promise:readline-input:18:0&gt;
&gt; (define bar (delay (+ 1 100)))
&gt; (force bar)
101
</pre>
</div>

<p>
如上演示，可以通过 <code>delay</code> 函数，先对函数进行承诺，可以看到 <code>delay</code> 的表达式是个 promise 。
然后可以通过 <code>force</code> 函数唤醒表达式，进行计算。
</p>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 求值器的变形</h3>
<div class="outline-text-3" id="text-5-5">
</div><div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1"><span class="section-number-4">5.5.1</span> STREAM</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
PROMISE 的一个应用就是 STREAM （流），先承诺后运算也叫LAZY EVALUATION（惰性计算）。
</p>

<p>
比如：读取文件时，一个一个字节读，就组成一个流，来一个字节处理一次。
</p>

<p>
流的模型如下：
</p>
<pre class="example">
+--------------------+
| PROMISE            |
|                    |
|    +-----------+   |
|    |EXP        |   |
|    |           |   |
|    | (force p) |   |
|    +-----------+   |
|                    |
+--------------------+
</pre>

<p>
外层包装了PROMISE，里面在需要执行的时候使用 <code>force</code> 唤醒表达式。
一次一次的处理过程就像太极一样，来回推导。
</p>
</div>
</div>

<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2"><span class="section-number-4">5.5.2</span> AMB</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
NON-DETERMINISITIC 意为不确定性计算。
在泛极中，正、常、奇、混四种状态中的混，引出了非确定性计算。
</p>

<p>
这里面引出 AMBIGUITY OPERATOR 歧义算子。
就像老鼠进入迷宫，老鼠可能成功找到出口，也可能失败。老鼠如何选择路线则是表达式，迷宫则是整个算式的环境。
这就引出四个参数：
</p>

<ul class="org-ul">
<li>FAILURE 失败的处理
</li>
<li>SUCCESS 成功的处理
</li>
<li>ENV 环境
</li>
<li>EXP 表达式
</li>
</ul>

<p>
在每个岔路口选择路线时，EXP和ENV都在变。
</p>

<p>
在选择失败了后，通过回溯，从新选择新的路线，直到最后成功。除非迷宫没有出口，这是 error 特殊情况。
</p>

<p>
迷宫问题其实模型就是一个树，如下：
</p>

<pre class="example">
               +-+
               | |   &lt;-- ENTRANCE
               +++
                |
    +-----------------------+
    |           |           |
    v           v           v
   +++         +++         +++
   | |         | |         | |
   +++         +++         +++
    |           |           |
+-------+   +-------+   +-------+
|   |   |   |   |   |   |   |   |
v   v   v   v   v   v   v   v   v
               +++
               | |
               +++
                |
            +-------+
            |   |   |
            v   v   v &lt;-- EXIT
</pre>

<p>
比如一个编译器，需要语法检查、语义检查，会一层一层检查下去。
</p>

<p>
在编译器中有两大算法
</p>

<ul class="org-ul">
<li>GEN-PATCH 生成-匹配 从上到下
</li>
<li>SHIFT-REDUCTION 移进-规约 从下到上
</li>
</ul>

<p>
不确定性计算的模型如下:
</p>

<pre class="example">
+------------+
| ENV        |
|  +-----+   |
|  |EXP  |   |
|  +-----+   |
|            |
+------------+
</pre>

<p>
外层是 ENV 整体环境，内层是 EXP 表达式。整体环境和表达式是固定的，但是会根据每次选择的情况选择适合的表达式。
</p>
</div>
</div>

<div id="outline-container-sec-5-5-3" class="outline-4">
<h4 id="sec-5-5-3"><span class="section-number-4">5.5.3</span> LOGIC PROGRAMMING</h4>
<div class="outline-text-4" id="text-5-5-3">
<p>
在前两种变形的基础上引出了 LOGIC PROGRAMMING 逻辑运算。
</p>

<p>
在BNF（EBNF）范式中，逻辑运算通过断言组织成一棵树。
</p>

<p>
这里面同样有 SK 、FK ，即成功之后的操作和失败之后的操作。
这些表达式与 LOGIC RULES 逻辑规则 等一起组成了当前逻辑运算的 ENV 。
</p>

<p>
逻辑运算和上一个变形不同在于，逻辑运算的EXP/ENV都在变化。
</p>

<p>
逻辑运算中的问题是不确定的，因此需要运用 STREAM （流）将所有的问题枚举出来，一个一个解决。
</p>

<p>
问题的解决可以通过 AMB （非确定性计算），当成图与图的对比。
</p>

<p>
该变形的模型如下：
</p>
<pre class="example">
+^-^-^-^-^-^-+
&lt; ENV        &gt;
|  +-^-^-+   |
&lt;  &lt;EXP  &gt;   &gt;
|  +-^-^-+   |
&lt;            &gt;
+-^-^-^-^-^-^+
</pre>

<p>
这些求值器的变形是人工智能的基础，只有知道这些理论才能够解决人工智能问题。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> 泛系方法论</h3>
<div class="outline-text-3" id="text-5-6">
<p>
泛系方法论是洪老师推崇的方法论，模型为：*PM 1 2 3* ，用来描述项目中的关系。
</p>

<ol class="org-ol">
<li>刻度理论 用来评判事物的尺度，分门别类的处理
</li>
<li>形式语言（BNF）建立问题的模型，把问题表达出来
</li>
<li>工程化方法 用数学知识对待关系
</li>
</ol>

<p>
有三中数学技术，可以等价的解决问题
</p>

<ul class="org-ul">
<li>集合论 SET
</li>
<li>图论 GRAPH
</li>
<li>MATRIX 矩阵
</li>
</ul>

<p>
可以看情况，选择合适的工具。
</p>

<p>
依次通过 1 2 3 点完成关系描述，然后去计算：(EVAL EXP ENV)。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Racket 第五课</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 昨日复习</h3>
<div class="outline-text-3" id="text-6-1">
<p>
除了前几天学习的内容，还有很多Racket知识没有学习，比如：读写文件、正则表达式、合同等。
这些知识可以在做小项目中学习。
</p>

<p>
首先学习了计算的本质 -&gt; 学习LISP。
</p>

<ul class="org-ul">
<li>最初的语言使用 MACHINE CODE ，ASSEMBLY CODE（汇编）
</li>
<li>Fortune、C语言引入了函数
</li>
<li>C++/JAVA 引入了 TYPE（Class） ，在LISP中引入 CLOSEURE （闭包）
</li>
</ul>

<p>
LISP中 CLOSEURE 就是 lambda表达式（λ-exp），define 绑定 key-value （键值对）,cons 函数创造 PAIR （偶对）。
通过 alist （属于PROPER LIST）存储多个偶对，可以构成一个数据库，通过assoc函数可以对其进行操作。
</p>

<p>
REPL 求值过程中，两个公式：(eval exp env)、(apply proc arg)， apply 用于在求值过程中构造临时表达式。
</p>

<p>
三种求值器的变形： STREAM 、 回溯 、 逻辑运算。
</p>

<p>
。。。。。。
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 人工智能导论</h3>
<div class="outline-text-3" id="text-6-2">
<p>
人工智能（AI）分为4个部分介绍。
</p>

<ul class="org-ul">
<li>AI 简介
</li>
<li>AI ETHODOCOGY 人工智能方法论
</li>
<li>LISP与AI的关系
</li>
<li>AI的方向 CASE STUDIES
</li>
</ul>
</div>

<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> 一 AI 简介</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
人脑中有10的12次方个神经元，而其中的大部分都没有被开发。
</p>

<p>
人有八识：
</p>

<ul class="org-ul">
<li>五官
</li>
<li>六识 由记忆组成
</li>
<li>七识 末那（梵语：manas） 比如：一眼认出老朋友，这是一种模式识别。
</li>
<li>八识 Alaye 指识之本体，人的潜能，人能调用另一个自己对自己产生认识。
</li>
</ul>

<p>
AI指让计算机模拟人的某方面能力。
</p>
</div>
</div>

<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> 二 AI ETHODOCOGY</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
AI问题解题的方法论，分为三个共同特点：
</p>

<ul class="org-ul">
<li>TARGET 问题的目标
</li>
<li>STATE 求解的过程、状态的变化、问题的转化
</li>
<li>OPERATE 操作
</li>
</ul>

<p>
这三点是解决所有AI问题所共同拥有的方面。
</p>

<p>
举个例子：一个老虎妈妈带着两个虎孩子和一个豹子要过河，豹子不能和虎孩子单独待在一起。
而过河的小船只能坐两只动物，并且只有虎妈妈才能划船，请问，它们该如何过河？
</p>

<p>
对于这个问题，就是排列组合（COMRINATION AERMMCATION），尝试找到成功的排列。
</p>

<p>
把人工智能可以分为3个层次，最底层是
</p>

<ul class="org-ul">
<li>查找与排序 SEARCH &amp; SORT
</li>
</ul>

<p>
但是当基数太大时，要避免组合爆炸。因此组合的复杂度不能是n的阶乘那样，几何增加，可以是n的平方、n的次方。
</p>

<p>
查找与排序 中，关键是降低复杂度，对问题空间进行聚类，商化。
</p>

<p>
第二层是：
</p>

<ul class="org-ul">
<li>建立模式 PATTERN 这是AI的核心。
</li>
</ul>

<p>
最上层就是应用：
</p>

<ul class="org-ul">
<li>应用 如：下棋、证明、机器学习、自然语言、图像识别等。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><span class="section-number-4">6.2.3</span> 三 LISP与AI的关系</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
在 PM 1 2 3 理论中，可以通过集合、图（网）、矩阵来解决问题。
</p>

<p>
解决问题的模型如下：
</p>

<pre class="example">
+-----------+
|           | &lt;--- 构造解题空间
|  +-----+  |
|  |o o o|&lt;-+----- 问题空间
|  | o o |  |
|  +-----+  |
|           |
+-----------+
</pre>

<p>
如果用图，则可以把图进行商化，对子问题进行求解。
商化的子集里是个偏序结构。
问题组成一个TREE树结构，而TREE是LIST的嵌套，所以用LSIP语言来处理AI问题。
</p>
</div>
</div>

<div id="outline-container-sec-6-2-4" class="outline-4">
<h4 id="sec-6-2-4"><span class="section-number-4">6.2.4</span> 四 CAE STUDIES</h4>
<div class="outline-text-4" id="text-6-2-4">
</div><ol class="org-ol"><li><a id="sec-6-2-4-1" name="sec-6-2-4-1"></a>自然语言处理<br  /><div class="outline-text-5" id="text-6-2-4-1">
<p>
对语言的处理不像处理数字那么简单。
</p>

<p>
比如： I READ A BOOK ==》 (READ I A.BOOK)
</p>

<p>
BOOK还有一些属性，如：
(BOOK ATTRIBUTES ((LENGTH THICK) (DIFFICUTY DIFF) (TOPIC A)))
</p>

<p>
这些属性是内节点。
</p>

<p>
如果这本书是我十年前读过的，那么这个描述是外节点：(READ I 10-YEARS-AGO)。
</p>

<p>
处理结构如下：
</p>

<pre class="example">
        +
        |
 +---------------+
 |      |        |
 v      v        v
READ    I    BOOK(...)    &lt;-- 内属性（PROPERTY）
                 +
                 |
          +------+---------+   &lt;-- 外属性（PROPERTY）
          |      |         |
          v      v         v
         READ    I    10-YEARS-AGO
</pre>

<p>
老的LISP里面有 PLIST 来存储这些数据，而Racket里面没有 PLIST 取而代之的是 ALIST。
</p>
</div>
</li>

<li><a id="sec-6-2-4-2" name="sec-6-2-4-2"></a>图像识别 GRAPH RECONGITION<br  /><div class="outline-text-5" id="text-6-2-4-2">
<p>
人眼就像两个 SENSORS （传感器），传递 SIGNALS （信号）给大脑。如果是用计算机处理这些信号，需要 A/D 转换。
</p>

<p>
比如人识别桌子的边角，大脑里面有对应的模式能够识别。如果用计算机处理，我们需要找到特征值。
可以把它变成线性代数问题，从而转化问题，解决问题。
</p>
</div>
</li>

<li><a id="sec-6-2-4-3" name="sec-6-2-4-3"></a>机器学习 MACHINE LEARNTING<br  /><div class="outline-text-5" id="text-6-2-4-3">
<p>
机器学习就是通过给予样本，让计算机自己学习，从中发现规律。
</p>

<p>
这就是一个不断积累的过程，把经验存放在集合里。
</p>
</div>
</li></ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: hexingpeng</p>
<p class="date">Created: 2016-11-23 三 19:21</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
