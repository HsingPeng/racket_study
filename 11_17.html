<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>11_17</title>
<!-- 2016-11-17 四 23:34 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="hexingpeng" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">11_17</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Racket第四课</a>
<ul>
<li><a href="#sec-1-1">1.1. 复习昨天的内容</a></li>
<li><a href="#sec-1-2">1.2. 求值器第二课</a></li>
<li><a href="#sec-1-3">1.3. call/cc 函数</a></li>
<li><a href="#sec-1-4">1.4. PROMISE</a></li>
<li><a href="#sec-1-5">1.5. 求值器的变形</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. STREAM</a></li>
<li><a href="#sec-1-5-2">1.5.2. AMB</a></li>
<li><a href="#sec-1-5-3">1.5.3. LOGIC PROGRAMMING</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. 泛系方法论</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Racket第四课</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 复习昨天的内容</h3>
<div class="outline-text-3" id="text-1-1">
<p>
LISP 就是 LIST PROCESSOR ，说到了Alist、assoc函数、QUASI-QUOTATION。
</p>

<p>
REPL的R、P是I/O部分，核心是 EVALUATOR 求值器。
</p>

<p>
求值器模型： <i>(eval exp env )</i> ，首先根据类型分类对策， <i>env</i> 环境中的数据用alist存放，相当于数据库。
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 求值器第二课</h3>
<div class="outline-text-3" id="text-1-2">
<p>
把求值器展开更详细的说明，可以分为阴阳两部分。
在太极中阳代表动， <i>eval</i> 函数把表达式求值，则是阳的部分。
表达式的参数需要提前构造好，这个构造的过程是阴的过程。
求值器里使用 <i>(apply proc arg)</i> 函数来把参数 arg 传递给 proc 。
<i>apply</i> 执行的过程就是阴。
</p>

<p>
求值器是阴与阳的泛导，是不断的太极推手的过程，直到所有的复杂函数运算完毕。
</p>

<p>
在Racket的运行时系统中，光有堆不够用了。计算过程至少有4个参数：
</p>

<ul class="org-ul">
<li>exp
</li>
<li>env
</li>
<li>proc
</li>
<li>argc
</li>
</ul>

<p>
所以使用中，至少需要4个寄存器访问。
</p>

<ul class="org-ul">
<li>有一些中间计算结果 &#x2013;&gt; val寄存器
</li>
<li>未完成 -&gt; unev寄存器
</li>
<li>还有跳转记录程序过程 -&gt; continue寄存器
</li>
</ul>

<p>
所以一共7个寄存器 + 堆栈 =&gt; 才能完成求值过程。
</p>

<p>
在Racket语言的内存中，帧框（栈帧）不一定是连在一起的，所以需要continue寄存器连接下一个帧框。
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> call/cc 函数</h3>
<div class="outline-text-3" id="text-1-3">
<p>
continue（连续）对象可以被捕获，在LISP中，可以使用 <code>call/cc</code> 函数来捕获连续对象。
</p>

<p>
<code>call/cc</code> 全称为 call with current continuation 。
</p>

<p>
比如： <code>(+ (* 3 7) (/ 8 2))</code> 如果把 <code>(/8 2)</code> 算式换成未知的函数，并用点代替。
</p>

<p>
函数就只能计算到 <code>(+ 21 ·)</code> ，等待后面的值。或者若如 <code>(+ · 4)</code> 所示，前面未完成，后面已完成，在等待唤醒使用。
</p>

<p>
这就叫连续。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))
25
</pre>
</div>

<p>
可以看到，在上式中，我们用 <code>call/cc</code> 捕获了该连续，然后把 <code>(/ 8 2)</code> 传入 <code>k</code> ， <code>k</code> 就是捕获的连续。
这样 <code>(/ 8 2)</code> 就被代入未完成的函数继续计算，结果仍然为25。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (define foo 1)
&gt; (+ (* 3 7) (call/cc (lambda (k) (set! foo k) (/ 8 2))))
25
&gt; (foo 4)
25
</pre>
</div>

<p>
在上式中，我们把foo绑定为k，所以foo函数的内容就变成了上式的连续，传入4，就会计算 <code>(+ 21 4)</code> ,结果同样是25。
</p>

<p>
在易经中，有
</p>

<ul class="org-ul">
<li>既济
</li>
<li>未济
</li>
</ul>

<p>
两卦，既济是指已完成，未济是指未完成。可以对应到上面的连续。
</p>

<p>
在内存中，捕获连续就是把帧框（栈帧）取出来，包装成对象。
</p>

<p>
捕获连续有4种典型用法：
</p>

<ol class="org-ol">
<li>JUMP(ESCAPE) 跳转，比如跳转到指定堆栈中去给值计算
</li>
<li>CO-ROUTINES 协例程 指相互调用
</li>
<li>BACKTRACK 回溯
</li>
<li>ENGINE 发动机机制 油=&gt;数据驱动
</li>
</ol>

<div class="org-src-container">

<pre class="src src-racket">(define foo
  (λ (lst)
    (call/cc
     (λ (k)
       (cond
	 [(null? lst) 'no]
	 [(eq? (car lst) #f) (k #t)]
	 [else (foo (cdr lst))])))))
; 'no
(foo '(1 2 3 4))
; #t
(foo '(1 2 3 4 #f 5))
</pre>
</div>

<p>
上式中的call/cc 捕获了lambda表达式，调用 foo 函数时，需要注意程序的执行顺序。
在程序没有遇到 <code>(k #t)</code> ，即 <code>K</code> 的调用处时，函数是正常执行的。
所以在 foo 函数递归到 lst 里第一个元素是 #f 时，就会执行到 <code>(k #t)</code> ， <code>call/cc</code> 就会捕获当前这个连续。
</p>

<p>
当前的连续就是该lambda表达式，因此当前表达式就变成了 <code>#t</code> ，所以就会输出 <code>#t</code> 。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (call/cc (lambda (k) (displayln (+ 2 3) (k 'done))))
'done
&gt; (eval ''done)
'done
</pre>
</div>

<p>
上述例子演示了捕获最外层的 <code>eval</code> 函数，等价效果如执行第二个 <code>eval</code> 函数。
</p>

<p>
在LISP中，连续式第一等对象。
</p>

<p>
从C语言的角度看 <code>call/cc</code> 的实现，利用了 &lt;setjump.h&gt; 库里的功能。
主要有 jump<sub>buf</sub> 结构，用于存放现场数据， setjump() 保存现场， longjump() 恢复现场。
</p>

<p>
在LISP的运行时系统（RUN-TIMESYSTEM）中，符号表是自含的（SELF-CONTAINED）。
符号表保存在内存中，并且栈框在内存中是不连续的，这就保证了灵活性。
</p>

<pre class="example">
  +--------+
..|........|.. &lt;-- 保存现场
. |        | .
. +--------+ .
. | \ \ \ \| . &lt;-- STACK FRAME
. |\ \ \ \ | . &lt;- - 表达式：(* 3 7)
. | \ \ \ \| . &lt;-- 计算结果：21
. +--------+ .
. |        | .
. |        | .
. +--------+ .
. | xxxxxx | .
. | xxxxxx | . &lt;-- STACK FRAME
. | xxxxxx | . &lt;-- 捕获处，未计算
. +--------+ .
. |        | .
..|... ....|..
  |        |
</pre>

<p>
以捕获 <code>(+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))</code> 为例，
如上图所示，在内存中，各个表达式所在的栈框在内存中是不连续的，并且 <code>(* 3 7)</code> 会完成计算，
和其他必须的数据一同被拷贝下来，复制到lambda所在的栈框执行。除了已完成计算的部分，其他未计算的部分都会被丢弃。
</p>

<p>
即：call/cc 后面未计算的部分会被丢弃。
</p>

<p>
基于LISP的栈不连续，用自含的符号表查询栈的位置，非常灵活。
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> PROMISE</h3>
<div class="outline-text-3" id="text-1-4">
<p>
SCHEME 默认是应用序，会先把参数算出来。
可以改成正则序，需要的时候再算。
</p>

<p>
PROMISE（承诺）就能够延迟运算表达式，就像加了层衣服。
</p>

<div class="org-src-container">

<pre class="src src-racket">&gt; (delay (+ 1 100))
#&lt;promise:readline-input:18:0&gt;
&gt; (define bar (delay (+ 1 100)))
&gt; (force bar)
101
</pre>
</div>

<p>
如上演示，可以通过 <code>delay</code> 函数，先对函数进行承诺，可以看到 <code>delay</code> 的表达式是个 promise 。
然后可以通过 <code>force</code> 函数唤醒表达式，进行计算。
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 求值器的变形</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> STREAM</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
PROMISE 的一个应用就是 STREAM （流），先承诺后运算也叫LAZY EVALUATION（惰性计算）。
</p>

<p>
比如：读取文件时，一个一个字节读，就组成一个流，来一个字节处理一次。
</p>

<p>
流的模型如下：
</p>
<pre class="example">
+--------------------+
| PROMISE            |
|                    |
|    +-----------+   |
|    |EXP        |   |
|    |           |   |
|    | (force p) |   |
|    +-----------+   |
|                    |
+--------------------+
</pre>

<p>
外层包装了PROMISE，里面在需要执行的时候使用 <code>force</code> 唤醒表达式。
一次一次的处理过程就像太极一样，来回推导。
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> AMB</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
NON-DETERMINISITIC 意为不确定性计算。
在泛极中，正、常、奇、混四种状态中的混，引出了非确定性计算。
</p>

<p>
这里面引出 AMBIGUITY OPERATOR 歧义算子。
就像老鼠进入迷宫，老鼠可能成功找到出口，也可能失败。老鼠如何选择路线则是表达式，迷宫则是整个算式的环境。
这就引出四个参数：
</p>

<ul class="org-ul">
<li>FAILURE 失败的处理
</li>
<li>SUCCESS 成功的处理
</li>
<li>ENV 环境
</li>
<li>EXP 表达式
</li>
</ul>

<p>
在每个岔路口选择路线时，EXP和ENV都在变。
</p>

<p>
在选择失败了后，通过回溯，从新选择新的路线，直到最后成功。除非迷宫没有出口，这是 error 特殊情况。
</p>

<p>
迷宫问题其实模型就是一个树，如下：
</p>

<pre class="example">
               +-+
               | |   &lt;-- ENTRANCE
               +++
                |
    +-----------------------+
    |           |           |
    v           v           v
   +++         +++         +++
   | |         | |         | |
   +++         +++         +++
    |           |           |
+-------+   +-------+   +-------+
|   |   |   |   |   |   |   |   |
v   v   v   v   v   v   v   v   v
               +++
               | |
               +++
                |
            +-------+
            |   |   |
            v   v   v &lt;-- EXIT
</pre>

<p>
比如一个编译器，需要语法检查、语义检查，会一层一层检查下去。
</p>

<p>
在编译器中有两大算法
</p>

<ul class="org-ul">
<li>GEN-PATCH 生成-匹配 从上到下
</li>
<li>SHIFT-REDUCTION 移进-规约 从下到上
</li>
</ul>

<p>
不确定性计算的模型如下:
</p>

<pre class="example">
+------------+
| ENV        |
|  +-----+   |
|  |EXP  |   |
|  +-----+   |
|            |
+------------+
</pre>

<p>
外层是 ENV 整体环境，内层是 EXP 表达式。整体环境和表达式是固定的，但是会根据每次选择的情况选择适合的表达式。
</p>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> LOGIC PROGRAMMING</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
在前两种变形的基础上引出了 LOGIC PROGRAMMING 逻辑运算。
</p>

<p>
在BNF（EBNF）范式中，逻辑运算通过断言组织成一棵树。
</p>

<p>
这里面同样有 SK 、FK ，即成功之后的操作和失败之后的操作。
这些表达式与 LOGIC RULES 逻辑规则 等一起组成了当前逻辑运算的 ENV 。
</p>

<p>
逻辑运算和上一个变形不同在于，逻辑运算的EXP/ENV都在变化。
</p>

<p>
逻辑运算中的问题是不确定的，因此需要运用 STREAM （流）将所有的问题枚举出来，一个一个解决。
</p>

<p>
问题的解决可以通过 AMB （非确定性计算），当成图与图的对比。
</p>

<p>
该变形的模型如下：
</p>
<pre class="example">
+^-^-^-^-^-^-+
&lt; ENV        &gt;
|  +-^-^-+   |
&lt;  &lt;EXP  &gt;   &gt;
|  +-^-^-+   |
&lt;            &gt;
+-^-^-^-^-^-^+
</pre>

<p>
这些求值器的变形是人工智能的基础，只有知道这些理论才能够解决人工智能问题。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 泛系方法论</h3>
<div class="outline-text-3" id="text-1-6">
<p>
泛系方法论是洪老师推崇的方法论，模型为：*PM 1 2 3* ，用来描述项目中的关系。
</p>

<ol class="org-ol">
<li>刻度理论 用来评判事物的尺度，分门别类的处理
</li>
<li>形式语言（BNF）建立问题的模型，把问题表达出来
</li>
<li>工程化方法 用数学知识对待关系
</li>
</ol>

<p>
有三中数学技术，可以等价的解决问题
</p>

<ul class="org-ul">
<li>集合论 SET
</li>
<li>图论 GRAPH
</li>
<li>MATRIX 矩阵
</li>
</ul>

<p>
可以看情况，选择合适的工具。
</p>

<p>
依次通过 1 2 3 点完成关系描述，然后去计算：(EVAL EXP ENV)。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: hexingpeng</p>
<p class="date">Created: 2016-11-17 四 23:34</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
