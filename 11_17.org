* Racket第四课

** 复习昨天的内容

LISP 就是 LIST PROCESSOR ，说到了Alist、assoc函数、QUASI-QUOTATION。

REPL的R、P是I/O部分，核心是 EVALUATOR 求值器。

求值器模型： /(eval exp env )/ ，首先根据类型分类对策， /env/ 环境中的数据用alist存放，相当于数据库。

** 求值器第二课

把求值器展开更详细的说明，可以分为阴阳两部分。
在太极中阳代表动， /eval/ 函数把表达式求值，则是阳的部分。
表达式的参数需要提前构造好，这个构造的过程是阴的过程。
求值器里使用 /(apply proc arg)/ 函数来把参数 arg 传递给 proc 。
/apply/ 执行的过程就是阴。

求值器是阴与阳的泛导，是不断的太极推手的过程，直到所有的复杂函数运算完毕。

在Racket的运行时系统中，光有堆不够用了。计算过程至少有4个参数：

- exp
- env
- proc
- argc

所以使用中，至少需要4个寄存器访问。

- 有一些中间计算结果 --> val寄存器
- 未完成 -> unev寄存器
- 还有跳转记录程序过程 -> continue寄存器

所以一共7个寄存器 + 堆栈 => 才能完成求值过程。

在Racket语言的内存中，帧框（栈帧）不一定是连在一起的，所以需要continue寄存器连接下一个帧框。

** call/cc 函数

continue（连续）对象可以被捕获，在LISP中，可以使用 =call/cc= 函数来捕获连续对象。

=call/cc= 全称为 call with current continuation 。

比如： =(+ (* 3 7) (/ 8 2))= 如果把 =(/8 2)= 算式换成未知的函数，并用点代替。

函数就只能计算到 =(+ 21 ·)= ，等待后面的值。或者若如 =(+ · 4)= 所示，前面未完成，后面已完成，在等待唤醒使用。

这就叫连续。

#+BEGIN_SRC racket
> (+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))
25
#+END_SRC

可以看到，在上式中，我们用 =call/cc= 捕获了该连续，然后把 =(/ 8 2)= 传入 =k= ， =k= 就是捕获的连续。
这样 =(/ 8 2)= 就被代入未完成的函数继续计算，结果仍然为25。

#+BEGIN_SRC racket
> (define foo 1)
> (+ (* 3 7) (call/cc (lambda (k) (set! foo k) (/ 8 2))))
25
> (foo 4)
25
#+END_SRC

在上式中，我们把foo绑定为k，所以foo函数的内容就变成了上式的连续，传入4，就会计算 =(+ 21 4)= ,结果同样是25。

在易经中，有

- 既济
- 未济

两卦，既济是指已完成，未济是指未完成。可以对应到上面的连续。

在内存中，捕获连续就是把帧框（栈帧）取出来，包装成对象。

捕获连续有4种典型用法：

1. JUMP(ESCAPE) 跳转，比如跳转到指定堆栈中去给值计算
2. CO-ROUTINES 协例程 指相互调用
3. BACKTRACK 回溯
4. ENGINE 发动机机制 油=>数据驱动

#+BEGIN_SRC racket
(define foo
  (λ (lst)
    (call/cc
     (λ (k)
       (cond
         [(null? lst) 'no]
         [(eq? (car lst) #f) (k #t)]
         [else (foo (cdr lst))])))))
; 'no
(foo '(1 2 3 4))
; #t
(foo '(1 2 3 4 #f 5))
#+END_SRC

上式中的call/cc 捕获了lambda表达式，调用 foo 函数时，需要注意程序的执行顺序。
在程序没有遇到 =(k #t)= ，即 =K= 的调用处时，函数是正常执行的。
所以在 foo 函数递归到 lst 里第一个元素是 #f 时，就会执行到 =(k #t)= ， =call/cc= 就会捕获当前这个连续。

当前的连续就是该lambda表达式，因此当前表达式就变成了 =#t= ，所以就会输出 =#t= 。

#+BEGIN_SRC racket
> (call/cc (lambda (k) (displayln (+ 2 3) (k 'done))))
'done
> (eval ''done)
'done
#+END_SRC

上述例子演示了捕获最外层的 =eval= 函数，等价效果如执行第二个 =eval= 函数。

在LISP中，连续式第一等对象。

从C语言的角度看 =call/cc= 的实现，利用了 <setjump.h> 库里的功能。
主要有 jump_buf 结构，用于存放现场数据， setjump() 保存现场， longjump() 恢复现场。

在LISP的运行时系统（RUN-TIMESYSTEM）中，符号表是自含的（SELF-CONTAINED）。
符号表保存在内存中，并且栈框在内存中是不连续的，这就保证了灵活性。

#+BEGIN_SRC
   +--------+
 ..|........|.. <-- 保存现场
 . |        | .
 . +--------+ .
 . | \ \ \ \| . <-- STACK FRAME
 . |\ \ \ \ | . <- - 表达式：(* 3 7)
 . | \ \ \ \| . <-- 计算结果：21
 . +--------+ .
 . |        | .
 . |        | .
 . +--------+ .
 . | xxxxxx | .
 . | xxxxxx | . <-- STACK FRAME
 . | xxxxxx | . <-- 捕获处，未计算
 . +--------+ .
 . |        | .
 ..|... ....|..
   |        |
#+END_SRC

以捕获 =(+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))= 为例，
如上图所示，在内存中，各个表达式所在的栈框在内存中是不连续的，并且 =(* 3 7)= 会完成计算，
和其他必须的数据一同被拷贝下来，复制到lambda所在的栈框执行。除了已完成计算的部分，其他未计算的部分都会被丢弃。

即：call/cc 后面未计算的部分会被丢弃。

基于LISP的栈不连续，用自含的符号表查询栈的位置，非常灵活。

** PROMISE

SCHEME 默认是应用序，会先把参数算出来。
可以改成正则序，需要的时候再算。

PROMISE（承诺）就能够延迟运算表达式，就像加了层衣服。

#+BEGIN_SRC racket
> (delay (+ 1 100))
#<promise:readline-input:18:0>
> (define bar (delay (+ 1 100)))
> (force bar)
101
#+END_SRC

如上演示，可以通过 =delay= 函数，先对函数进行承诺，可以看到 =delay= 的表达式是个 promise 。
然后可以通过 =force= 函数唤醒表达式，进行计算。

** 求值器的变形

*** STREAM

PROMISE 的一个应用就是 STREAM （流），先承诺后运算也叫LAZY EVALUATION（惰性计算）。

比如：读取文件时，一个一个字节读，就组成一个流，来一个字节处理一次。

流的模型如下：
#+BEGIN_SRC
+--------------------+
| PROMISE            |
|                    |
|    +-----------+   |
|    |EXP        |   |
|    |           |   |
|    | (force p) |   |
|    +-----------+   |
|                    |
+--------------------+
#+END_SRC

外层包装了PROMISE，里面在需要执行的时候使用 =force= 唤醒表达式。
一次一次的处理过程就像太极一样，来回推导。

*** AMB

NON-DETERMINISITIC 意为不确定性计算。
在泛极中，正、常、奇、混四种状态中的混，引出了非确定性计算。

这里面引出 AMBIGUITY OPERATOR 歧义算子。
就像老鼠进入迷宫，老鼠可能成功找到出口，也可能失败。老鼠如何选择路线则是表达式，迷宫则是整个算式的环境。
这就引出四个参数：

- FAILURE 失败的处理
- SUCCESS 成功的处理
- ENV 环境
- EXP 表达式

在每个岔路口选择路线时，EXP和ENV都在变。

在选择失败了后，通过回溯，从新选择新的路线，直到最后成功。除非迷宫没有出口，这是 error 特殊情况。

迷宫问题其实模型就是一个树，如下：

#+BEGIN_SRC
               +-+
               | |   <-- ENTRANCE
               +++
                |
    +-----------------------+
    |           |           |
    v           v           v
   +++         +++         +++
   | |         | |         | |
   +++         +++         +++
    |           |           |
+-------+   +-------+   +-------+
|   |   |   |   |   |   |   |   |
v   v   v   v   v   v   v   v   v
               +++
               | |
               +++
                |
            +-------+
            |   |   |
            v   v   v <-- EXIT
#+END_SRC

比如一个编译器，需要语法检查、语义检查，会一层一层检查下去。

在编译器中有两大算法

- GEN-PATCH 生成-匹配 从上到下
- SHIFT-REDUCTION 移进-规约 从下到上

不确定性计算的模型如下:

#+BEGIN_SRC
+------------+
| ENV        |
|  +-----+   |
|  |EXP  |   |
|  +-----+   |
|            |
+------------+
#+END_SRC

外层是 ENV 整体环境，内层是 EXP 表达式。整体环境和表达式是固定的，但是会根据每次选择的情况选择适合的表达式。

*** LOGIC PROGRAMMING

在前两种变形的基础上引出了 LOGIC PROGRAMMING 逻辑运算。

在BNF（EBNF）范式中，逻辑运算通过断言组织成一棵树。

这里面同样有 SK 、FK ，即成功之后的操作和失败之后的操作。
这些表达式与 LOGIC RULES 逻辑规则 等一起组成了当前逻辑运算的 ENV 。

逻辑运算和上一个变形不同在于，逻辑运算的EXP/ENV都在变化。

逻辑运算中的问题是不确定的，因此需要运用 STREAM （流）将所有的问题枚举出来，一个一个解决。

问题的解决可以通过 AMB （非确定性计算），当成图与图的对比。

该变形的模型如下：
#+BEGIN_SRC
+^-^-^-^-^-^-+
< ENV        >
|  +-^-^-+   |
<  <EXP  >   >
|  +-^-^-+   |
<            >
+-^-^-^-^-^-^+
#+END_SRC

这些求值器的变形是人工智能的基础，只有知道这些理论才能够解决人工智能问题。

** 泛系方法论

泛系方法论是洪老师推崇的方法论，模型为：*PM 1 2 3* ，用来描述项目中的关系。

1. 刻度理论 用来评判事物的尺度，分门别类的处理
2. 形式语言（BNF）建立问题的模型，把问题表达出来
3. 工程化方法 用数学知识对待关系

有三中数学技术，可以等价的解决问题

- 集合论 SET
- 图论 GRAPH
- MATRIX 矩阵

可以看情况，选择合适的工具。

依次通过 1 2 3 点完成关系描述，然后去计算：(EVAL EXP ENV)。

#+AUTHOR: hexingpeng
