* 课程简介

本次人工智能培训班讲课内容分为三大部分。

1. 计算的本质
2. Racket语言
3. AI方法论

* 第一课 计算的本质 & Racket第一课

时间：2016年11月14日

 *笔者注* ：本课基于离散数学、拓扑学、集合论、范畴学等领域知识归纳演绎得到，知识范围广、体量大，所以笔记中必有很多误解之处，望读者见谅。

** 计算的本质

我们将从数学、哲学、计算机三个角度来分析计算的本质。计算的本质在数学上分为六大关系：

1. 局整关系
2. 形影关系
3. 异同关系
4. 范序
5. 泛导
6. 泛极

*** 1 局整关系

通过集合论来表达关系。B属于A，那么B和A是局整关系。

*** 2 形影关系

指两个事物之间有关系，包括映射等都属于。笛卡尔坐标中(x,y)在X和Y轴的位置是典型的形影关系。

*** 3 异同关系

比如 /x ∈ seminar/ ,这个集合指：屋里的人都属于这个班。屋里的人和屋外的人有本质差异，这里存在隶属关系。

屋里的人和屋外的人是异同关系，这种 *异同关系产生了类型* ，屋里的人和屋外的人是不同的类型。

*** 4 泛序

泛序是指广义的排序。泛序分为三类：

1. 偏序
2. 全序
3. 良序

偏序指：某一部分可以找到某种排序关系。

全序指：所有元素有序。

良序指：有序元素的全序集合。

*** 5 泛导

泛导指广义的导数。广义上两个量在一起做比类叫泛导。泛导是从微积分中推广得到的概念。

*** 6 泛极

泛极是极限的推广，我们学过的收敛是其中的一种情况。包含以下几种状态：

- 奇 两个量的类型不一样，则不能表达。
- 混 混沌是一种常态，难以找到答案。
- 正常 比如：收敛。正指在一定范围内，常指度量、结果是常数。

*** 什么是关系？

关系是直积空间（DIRECT PRODUCT）的子集。

比如： /A {a1, a2, a3 ...}/ , /B {b1, b2, b3 ...}/ , /A*B/
 构成的新集合叫直积，如 /(a1, b1)/ 、 /(a1, b3)/ 。

形影关系、局整关系 => 通过运筹 => 得到关系的数学版本。

有了集合的基本概念，除了直积、还有差集、补集等才能够研究映射关系。

度量集合可以从以下几点：

1. 基数：元素的个数
2. 序数：排序
3. 纲：无穷中有粒度问题，第一纲（自然数），第二纲（连续统），就如连续统比自然数大。

还有代数系统部分。代数系统研究三元关系，两个元素运算得到一个新的元素。分为：

- 内部运算
- 外部运算

比如： /3x7=21/ 产生新的数 21 仍然属于自然数，这叫内部运算。外部运算则产生不属于原集合的数。
内部运算具有封闭性。从代数系统里研究得到律、环、群等，如：结合律、分配率。

*** 集合论

集合论内容有：

- 概念
- 谈论关系和映射
- 测度、考虑元素基数
- 考虑排序
- 格的理论
- 代数系统
- 泛序论

为了描述计算的本质，可转化为八则运算。
比如：交集是做减法，集合的乘法构造空间，除法：平面->投影->分量，并集->加法，从直积空间分解->集合。

利用这种等价关系进行等价聚类。等价关系是指满足：

1. 自反关系
2. 反对称
3. 传递性

这在数学中很重要。

*** ICBE 理论

从集合出发可以发展出 *ICBE* 理论。

- I：INTER 内部
- E：EXTERNAL 外部
- C：CLOSURE 导集
- B：BOUNDARY 边界

导集 => 闭包：无论系统如何扩大都在内部

哲学有本体论、存在论等。

在拓扑空间 T 中有几个定理：

- 定理1：空集 ∅ 是一个元素
- 定理2：A集合视为一个元素
- 定理3：集合内部空集的点构成的子集是一个元素
- 定理4： T 与内部子集做加法仍然是 T

用拓扑学知识来研究数学，前提就是有存在性。

有存在性，拓扑结构一定有个边界 => 异同关系。
边界产生抽象屏障（ABSTRACT BARRIER），比如LAMBDA表达式就是一个闭包，就是一个抽象屏障。

** Racket语言

*** 定义一个函数

Racket属于LISP的一种实现。在LISP中定义一个函数名 foo ，并使用 lambda 定义一个表达式：

#+BEGIN_SRC racket
(lambda ()
   "HELLO WORLD")
#+END_SRC

定义 foo 函数的完整语句如下：

#+BEGIN_SRC racket
(define
  foo
    (lambda ()
    "HELLO WORLD"))
#+END_SRC

这实际上就是一个闭包。

*** 运算

=(foo)= 把 foo 放入表达式运算

=(lamdba () "Hello world")= 结果： =“Hello world”=

=(lambda display "Hello world")= 结果： =hello world=

 LISP 语言中没有赋值，当语言中有赋值操作就需要关注寄存器的状态。

*** 列表

 LISP 中的列表:

#+BEGIN_SRC emacs-lisp
'(1 2 3 4 5)
#+END_SRC

输入'(foo)则会打印'(foo),因为加上'(...)则是数据。

*** 函数

**** 第一等对象

在LISP中，函数是第一等对象。

第一等对象指：

1. 可以被返回
2. 可以被传递
3. 可以被重命名，被调用。

比如在C语言中，函数不是第一等对象，因为函数不能被传递，但是函数指针可以。

函数举例：

#+BEGIN_SRC emacs-lisp
; squre函数
(define square
  (λ (x)
    (* x x)))

; cubic函数
(define cubic
  (λ (x)
    (* (square x) x)))

; c2函数
(define c2
  (λ (foo x)
    (* (foo x) x)))

; 函数可以被返回
(λ ()
  (λ ()
    "Hello world"))

; 该函数构造数据:偶对 '(1.2)
(cons 1 2)

;结果：'(1 (2.3))
(cons 1 (cons 2 3))
#+END_SRC

**** 应用序 正则序

- 应用序：如 (Racket)Lisp
- 正则序：先化简后运算，如：Haskell => Lasy求值（惰性求值）


**** car cdr

#+BEGIN_SRC emacs-lisp
; 结果 1
(car '(1.2))

; 结果 2
(cdr '(1,2))
#+END_SRC

car 函数取出第一个数， cdr 函数去除第一个数，取出后面的数。

**** ‘()

'() 代表空表，列表最后一个元素都为空。如：'(1 2 3 4 5 '())。

'(2 '(3 4) 5) 是嵌套列表。



*** 宏

LISP可以定义自己的宏（marco），所以适合做DSL（领域专用语言）和编译器。

*** 可计算函数构造方法

1. 前继函数
2. 后续函数
3. 测零函数
4. 不动点函数

从数理逻辑角度程序需要这四类函数。

*** 搜索举例

列表元素搜索从外到内一层一层找。

#+BEGIN_SRC emacs-lisp
#lang racket

(define search
  (lambda (l x)
    (cond
      [(null? l) 'not_found]
      [(= x (car l)) 'found]
      [else (search (cdr l) x)])))
(search '(1 2 3 4 5))
#+END_SRC

* Racket第二课 -- 12个Racket编程要点（上）

** 要点总览

1. λ-excp （lambda表达式）
2. INTERNAL DEFINITION （内部定义）
3. SYMBOLIC TABLE （符号表）
4. FRIST-CLASS OBJECT （函数属于第一等对象）
5. DISPATCH FUNCTION （发派函数）
6. LET SPECIAL FORM (嵌套闭包)
7. LETREC （相互调用）
8. NAMED LOOP (尾递归 TAIL-RECURSION)
9. LIST PROCESS FUNCTIONS （关联列表 alist，链表 assoc）
10. DATABASE (用派发函数 DISPATCH FUNC 操作数据库)
11. QUASI-QUOTATION (准引用)
12. EVALUATOR(REPL) (高阶算子 HIGHER ORDER OPERATOR)

** 1. λ-excp

Lambda表达式缩写为λ，lambda表达式就是一个闭包。

*THUNK* ：我们把lambda表达式没有参数这种情况叫做 THUNK ，译作悟空。

#+BEGIN_SRC racket
比如函数
  (λ ()    ;没有参数
    (* 100 100))
#+END_SRC

闭包的特性：只有一个口可以进去，参数也通过此传入进去。

表达式参数有三种写法。

- λ (x y) 两个或多个参数
- λ (x . y) 左边一部分是确定的，如：(x y . z)。后面的会被当做列表
- λ (x) 参数个数不限，会合并成一个列表传入

示例如下：
#+BEGIN_SRC racket
#lang racket

(define f2 (λ (x . y) (displayln x)))
;结果 1
(f2 1 2 3 4 5)
; (1 2 3)
(f2 '(1 2 3))
; 1
(f2 1 2 3)

(define f3 (λ (x . y) (displayln (car y))))
; 2
(f3 1 2 3)

(define f4 (λ (x . y) (displayln (cdr y))))
; (3)
(f4 1 2 3)

(define f5 (λ (x . y) (displayln (cadr y))))
; 3
(f5 1 2 3 4 5)

(define f6 (λ (x . y) (displayln (cddr y))))
; (4 5)
(f6 1 2 3 4 5)

(define f7 (λ (x . y) (displayln (car x))))
; 1
(f7 '(1 2) 2 3)
#+END_SRC

** 2. INTERNAL DEFINITION

内部定义相当于在内部定义一个宪法，在外部用不了。

#+BEGIN_SRC racket
#lang racket

(λ ()
  (define c (λ (x)
              (* x x)))
  c) ；返回内部函数c

(define foo (lambda () (define f (λ (x) (* x x))) f))

((foo) 4)
#+END_SRC

在lambda里定义函数必须在使用该函数之前。

函数在LISP中是第一等对象，可被直接返回，另外利用 =valus= 可以返回多个。

** 3. SYMBOLIC TABLE

*符号表* 就如同表格，记录每个对象。 *在学习编程语言时一定要建立起符号表的概念，非常重要* 。

在老的LISP里有如下5个字段：


| 字段 | 解释                 |
|--------+------------------------|
| name   | 名称                 |
|--------+------------------------|
| type   | 类型                 |
|--------+------------------------|
| value  | 值                    |
|--------+------------------------|
| plist  | 有哪些proprity（属性） |
|--------+------------------------|
| lambda | λ表达式       |

在后来的 scheme 中，没有了 =plist= 字段，以及 =value= 和 =lamdba= 字段合并在一起。

在LISP有很多谓词（predicator），如： =(number? 100)= 。
可以用这些谓词查询类型，就是通过查询符号表 /type/ 。
可以做合同，约定类型，都和字符表有关。

/name/ 和 /lambda/ 是形影关系，绑定（bound）在一起。

=define= 的本质是建立偶对，每次 =define= 都在字符表中插入一条记录，若相同的名称定义了第二次，则会删除原记录，新建一个记录。

LISP中有垃圾回收机制，会回收不用的数据。

符号表是计算机科学的中心数据结构。

** 4. FRIST-CLASS OBJECT

第一等对象指：

- 可以被返回。
- 可以被传递。
- 可以被命名，作为一个单独的条目存在符号表中。
- 可以和其他类型构成数据结构。

LISP中的函数是第一等对象。

** 5. DISPATCH FUNCTION

发派函数的核心思想是： *对外扫相、对内破执* 。

意思是从外部提供相应的符号，拿到闭包内用对于的函数做相应的计算。

这种方式属于数据提供的编程。


比如：
#+BEGIN_SRC racket
#lang racket

;定义发派函数
(define foo
  (λ (s)
  (define (f1) (displayln 'present-flower))
  (define (f2) (displayln 'provide-money))
  (define d (lambda ()
  (cond
    [(equal? s 'beautilful) (f1)]
    [(equal? s 'poor) (f2)])))
  d))

;使用
((foo 'poor))
#+END_SRC

** 6. LET SPECIAL FORM

匿名表达式（anonymous）通过 =define= 操作变成有名函数（named）。

#+BEGIN_SRC racket
; 例1：匿名表达式
((λ (x y)
   (* x y))
 100
 200)

; 例2：通过let绑定多个对象
(let ((x 100)
      (y 200))
      (* x y))

; 例3：嵌套使用
(let ((x 100)
      (y 200))
  (let ((z 300))
    (* x y z)))

; 例4：使用let* 互相绑定，则无需嵌套
(let* ((x 1)
       (y 2)
       (z (* x y)))
  (* x y z))
#+END_SRC

*注意* ：就如 例3 所示，两个闭包嵌套使用。在外层的闭包只可以使用内层的对象，如例子中的z。
但是对于处于同一层次的对象 x y 则不能相互调用，如果x的绑定中用到了y则是错误的。

这时可以使用 =let*= 避免嵌套，如 例4 所示，这时一种语法糖（句法糖）。

** 7. LETREC

#+BEGIN_SRC racket
(define is-even?
  (λ (x)
    (if (= x 0)
        #t
        (is-odd? (- x 1)))))
(define is-odd?
  (λ (x)
    (if (= x 0)
        #f
        (is-even? (- x 1)))))

(is-even? 100)
(is-even? 101)
(is-odd? 9)
#+END_SRC

上例为计算是否为偶数和奇数的两个函数，两个函数有相互调用的关系。
我们可以不用一个一个定义两个函数，可以结合在一起同时定义。

可以使用 =letrec= ，如下所示：
#+BEGIN_SRC racket
(letrec ((is-even?
          (λ (x)
            (if (= x 0)
                #t
                (is-odd? (- x 1)))))
         (is-odd?
          (λ (x)
            (if (= x 0)
                #f
                (is-even? (- x 1))))))
  (is-even? 100)
  (is-even? 101))
#+END_SRC

这里面任意闭包都可以相互调用。

** 8. NAMED LOOP

下例展示一种常规的递归方法。
#+BEGIN_SRC racket
; 一种递归 空间效率差
(define
  factorial
  (λ (n)
    (if (= n 0)
        1
        (* n (factorial (- n 1))))))

(factorial 5)
#+END_SRC

上例中的递归由于需要嵌套的调用函数，虽然逻辑清晰，但是会导致空间效率特别差。

我们可以使用尾递归，在恒定的空间内部运算，没有空间效率损失。
如下例所示，就是尾递归的写法。
 
使用 =let= 来绑定函数，在内部调用该函数时会回到之前所在位置执行，个人理解类似C语言中的 =goto= 。

#+BEGIN_SRC racket
;尾递归
(define fac (λ (n)
              (let loop ([i n]
                         [k 1])
                (if (= i 0)
                    k
                    (loop (- i 1) (* i k))))))
(fac 4)
#+END_SRC
* Racket第三课 - 12个Racket编程要点（下）

** 上节课 尾递归 知识更正

尾递归指一个函数所有递归形式的调用都出现在函数末尾，我们称这种递归为尾递归。

#+BEGIN_SRC racket
; 一种递归 空间效率差
(define
  factorial
  (λ (n)
    (if (= n 0)
	1
	(* n (factorial (- n 1))))))

;尾递归
(define fac (λ (n)
              (let loop ([i n]
                         [k 1])
                (if (= i 0)
                    k
                    (loop (- i 1) (* i k)))))
#+END_SRC

可以看到，第一种递归虽然在函数末尾调用，但是在调用中，函数处于运算中。
在这种情况下编译器不能够进行优化，导致递归仍然需要创建栈帧。

所以需要以直接调用的形式放在末尾，编译器才能够优化代码，在原有的栈帧空间执行。

** 编译原理知识补充

 *编译原理* 很重要。

编译原理有 *活动记录* 的概念，表示一个过程的一次执行所需信息的管理。

 *编译* 和 *解释* 都是做翻译。解释是一句一句翻译，但是编译像批处理。

从数据结构操作的算法来看，编译本质上是对符号表的增删改查的操作。

C语言和LISP语言不一样，除了语法和编译不同以外，关键是运行时系统不一样。

*** 运行时系统

在运行时的系统中，程序有两部分：

- program 程序处理部分 => CS
- data 数据部分 => DS DI SI

在运行中，就有代码段和数据段。处理器每次接收一个时钟都向前运行一行代码。
在X86机器上，有个PC(IP)程序计数器指向代码的位置。

由程序处理部分引出CS寄存器，代码段地址寄存器。

由数据部分引出DS数据段段寄存器，DI目的变址寄存器，SI源变址寄存器。
DS做中转，DI指示写到那里去，SI指示数据从哪读取进来。

早期的FORTRAN语言只要这几个寄存器就够了。

*** 堆栈（栈）

后来C、ALGOL等引入了堆栈（栈）的思想。

#+BEGIN_SRC
|   .    |  <-- SS
|   .    |
|        |
|--------|  <-- BP
| .....  |
| .....  |  <-- SP
| .....  |
|--------|
|        |
|   .    |
|   .    |
|        |
#+END_SRC

SS寄存器指向堆栈的起始地址，BP寄存器指向框的起点（栈帧的起点），SP堆栈指针指向所需位置，

但是堆栈（栈）有个缺点，弹出就没有了，所以引出了堆的概念。

*** 附加段（堆）

堆（HEAP）引出了ES寄存器，用来操作内存空间。
内存空间可以分为代码段、数据段、堆栈段、附加段三个部分。

为了更加方便的操作，引出了AX、BX、CX、DX四个通用寄存器。


加上用于存储计算机状态的Flag标志位寄存器，在8086 CPU上一共有14个寄存器。

- 4个数据寄存器(AX、BX、CX和DX)
- 2个变址和指针寄存器(SI和DI)
- 2个指针寄存器(SP和BP)
- 4个段寄存器(CS、SS、DS、ES)
- 1个指令指针寄存器(IP)
- 1个标志寄存器(EFlags)

*** 栈框

栈框就是指栈帧，一个函数运行时的栈空间，栈帧也叫过程活动记录。

ALGOL语言把堆栈分为7个部分。

#+BEGIN_SRC
|   .    |
|   .    |
|        |
|--------|
|  IN    | <- 输入数据
|--------|
|  OUT   | <- 输出数据
|--------|
| LOCAL  | <- 局部变量
|--------|
| TEMP   | <- 中间结果
|--------|
| SAVED  | <- 保存的机器状态
|--------|
| DATA   | <- 数据链
|--------|
| FUNC   | <- 函数（动态）链
|--------|
|        |
|   .    |
|   .    |
|        |
#+END_SRC

在C语言里，帧框中没有保留状态部分，没有数据链和函数链。

在SCHEME语言里，DATA和FUNC合二为一。

在尾递归中，帧框里的IN、OUT改变，不会增框。

** 9 LIST PROCESS FUNCTIONS

LIST PROCESS FUNCTIONS 指列表处理函数。

Racket中有两种非常重要的数据类型，列表和偶对。

并且在Racket中，有一系列函数用于列表处理。如：

- car cdar cddar
- cdr cadr

car用于取出列表的第一个元素，cdr用于取出列表中除去第一个元素，后面的元素组成的新列表。

list函数用于创建列表。

#+BEGIN_SRC racket
; '(1 2 3 4 5 6)
(list 1 2 3 4 5 6)
#+END_SRC

cons函数用于创造偶对。

#+BEGIN_SRC racket
; '(2 . 3)
(cons 2 3)

; '(2)
(cons 2 '())

; '(1 2 3)
(cons 1 '(2 3))
#+END_SRC

一些列表处理函数示例：

#+BEGIN_SRC racket
; '(1 2 3 4)
(append '(1 2) '(3 4))

; '(3 2 1)
(reverse '(1 2 3))
#+END_SRC

列表处理函数的原理都是对符号表进行操作。

完整的列表处理函数在安装Racket之后可以执行 =plt-help= 命令打开官方帮助文档查看。

** 10 DATABASE 

这个数据库指在Racket语言编程中，程序运行时，创建数据库。

在大型软件中，一个系统需要分解成模块来完成，使用模块化思想。这里有：

- mechanism 机制 
- function 功能

内部的机制和外在的功能一对概念。使用者不需要知道里面的机制，只需要知道功能。

内部的提供的机制通过数据库的形式组织起来。

在Racket中，数据库可以看做绑定（bound）的集合。

列表是最通用的容器，可以放很多的绑定（偶对）。 

在Racket有专门的列表，叫/alist/ （关联的列表），用来存放一个个偶对。
如： '((x . 200 (g . 200))) 。

可以看出来 /alist/ 就是一个数据库。

可以使用派发函数来操作数据库，五种操作：

- 增 INSERT
- 删 DELETE
- 改 MULATE
- 查 SEARCH
- 排序 SORT

有个 =assoc= 函数可以根据提供的标识符在 /alist/ 中查找偶对。

#+BEGIN_SRC racket
(define lst '((x 100) (y 100) (z (lambda () (* 10 10)))))
; '(x 100)
(assoc 'x lst)
#+END_SRC

*** 列表、偶对的结构

在LISP中，列表是偶对的嵌套。
计算的本质六大关系中的 泛导 -> 偶对，泛极 -> 测零。

#+BEGIN_SRC racket
> (list 1 2 3)
'(1 2 3)
> (cons 1 (cons 2 (cons 3 '())))
'(1 2 3)
> (cons 1 '(2 3))
'(1 2 3)
> (cons 1 (cons 2 3))
'(1 2 . 3)
#+END_SRC

从上面四个语句创建的数据，可以看出来，前三个语句创建的列表完全相同，为 '(1 2 3)。

我们看一下这个列表 '(1 2 3) 在内存中的结构：

#+BEGIN_SRC racket

+---+---+      +---+---+      +---+---+
|   |   +----> |   |   +----> |   |   +---> '()
+-+-+---+      +-+-+---+      +-+-+---+
  |              |              |
  +--> 1         +--> 2         +--> 3

#+END_SRC

而最后一个列表 '(1 2 . 3) 在内村中的结构如下：

#+BEGIN_SRC racket

+---+---+      +---+---+
|   |   +----> |   |   +----> 3
+-+-+---+      +-+-+---+
  |              |
  +--> 1         +--> 2

#+END_SRC

所以列表是由一个个嵌套的偶对组成的，而最后一个偶对的值是 '() ，可以忽略不写。

** 11 QUASI-QUOTATION

准引用能够将算式里的值计算后输出，符号 =`= （ESC下面的按键），区别于单引号 ' 。

示例：
#+BEGIN_SRC racket
; 引用
'(1 2 3)

; 准引用
`(1 2 3)

; '(1 3 3)
`(1 ,(+ 1 2) 3)

; '(1 (2 3) 4)
`(1 ,(list 2 3) 4)

; '(1 (2 3) (list 4 5))
`(1 ,(list 2 3) (list 4 5))

; '(1 2 3 (list 4 5))
`(1 ,@(list 2 3) (list 4 5))
#+END_SRC

准引用在宏（marco）中非常有用，用于符号计算。

** 12 EVALUATOR(REPL)

REPL指：
- READ 读取表达式
- EVALUATE 对读取的表达式求值
- PRINT 把求值的结果打印出来
- LOOP 循环

REPL就是LISP程序的基本流程。

求值的规则是LISP设计的关键，LISP核心是设计求值器。
说到求值的规则就回到了六大运算、八大规则。

求值器设计的核心就是 EVAL 函数： *(eval exp env)* 。

表达式的求值一定是在一个环境中，即 env 。

从哲学上来讲，对事物的评判一定是在一个限定的环境中，这是一个方法论，也是LISP的核心。

所以首先确定一个环境之后，再对需要的东西进行评估。

如何评判，首先看类型，比如：数字，偶对等，分类对策。

BNF范式就是用来定义类型系统的。

所以，在原有的派发函数基础上要加上一个环境，模型如图：
#+BEGIN_SRC

        eval
  +--------------+  <--- 外层环境
  |     env      |
  |   +-----+    |
  |   | exp |    |
  |   +-----+    |
  |    (alist) <-+--- 环境里有alist
  +--------------+

#+END_SRC

从闭包的角度，这就是两个闭包的嵌套。

环境里有个评判尺度，有alist存放数据，有增删改查排序5个操作，有cond函数分类对策，有派发函数来执行操作。

这就是LISP求值器设计的核心。
* Racket第四课

** 复习昨天的内容

LISP 就是 LIST PROCESSOR ，说到了Alist、assoc函数、QUASI-QUOTATION。

REPL的R、P是I/O部分，核心是 EVALUATOR 求值器。

求值器模型： /(eval exp env )/ ，首先根据类型分类对策， /env/ 环境中的数据用alist存放，相当于数据库。

** 求值器第二课

把求值器展开更详细的说明，可以分为阴阳两部分。
在太极中阳代表动， /eval/ 函数把表达式求值，则是阳的部分。
表达式的参数需要提前构造好，这个构造的过程是阴的过程。
求值器里使用 /(apply proc arg)/ 函数来把参数 arg 传递给 proc 。
/apply/ 执行的过程就是阴。

求值器是阴与阳的泛导，是不断的太极推手的过程，直到所有的复杂函数运算完毕。

在Racket的运行时系统中，光有堆不够用了。计算过程至少有4个参数：

- exp
- env
- proc
- argc

所以使用中，至少需要4个寄存器访问。

- 有一些中间计算结果 --> val寄存器
- 未完成 -> unev寄存器
- 还有跳转记录程序过程 -> continue寄存器

所以一共7个寄存器 + 堆栈 => 才能完成求值过程。

在Racket语言的内存中，帧框（栈帧）不一定是连在一起的，所以需要continue寄存器连接下一个帧框。

** call/cc 函数

continue（连续）对象可以被捕获，在LISP中，可以使用 =call/cc= 函数来捕获连续对象。

=call/cc= 全称为 call with current continuation 。

比如： =(+ (* 3 7) (/ 8 2))= 如果把 =(/8 2)= 算式换成未知的函数，并用点代替。

函数就只能计算到 =(+ 21 ·)= ，等待后面的值。或者若如 =(+ · 4)= 所示，前面未完成，后面已完成，在等待唤醒使用。

这就叫连续。

#+BEGIN_SRC racket
> (+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))
25
#+END_SRC

可以看到，在上式中，我们用 =call/cc= 捕获了该连续，然后把 =(/ 8 2)= 传入 =k= ， =k= 就是捕获的连续。
这样 =(/ 8 2)= 就被代入未完成的函数继续计算，结果仍然为25。

#+BEGIN_SRC racket
> (define foo 1)
> (+ (* 3 7) (call/cc (lambda (k) (set! foo k) (/ 8 2))))
25
> (foo 4)
25
#+END_SRC

在上式中，我们把foo绑定为k，所以foo函数的内容就变成了上式的连续，传入4，就会计算 =(+ 21 4)= ,结果同样是25。

在易经中，有

- 既济
- 未济

两卦，既济是指已完成，未济是指未完成。可以对应到上面的连续。

在内存中，捕获连续就是把帧框（栈帧）取出来，包装成对象。

捕获连续有4种典型用法：

1. JUMP(ESCAPE) 跳转，比如跳转到指定堆栈中去给值计算
2. CO-ROUTINES 协例程 指相互调用
3. BACKTRACK 回溯
4. ENGINE 发动机机制 油=>数据驱动

#+BEGIN_SRC racket
(define foo
  (λ (lst)
    (call/cc
     (λ (k)
       (cond
         [(null? lst) 'no]
         [(eq? (car lst) #f) (k #t)]
         [else (foo (cdr lst))])))))
; 'no
(foo '(1 2 3 4))
; #t
(foo '(1 2 3 4 #f 5))
#+END_SRC

上式中的call/cc 捕获了lambda表达式，调用 foo 函数时，需要注意程序的执行顺序。
在程序没有遇到 =(k #t)= ，即 =K= 的调用处时，函数是正常执行的。
所以在 foo 函数递归到 lst 里第一个元素是 #f 时，就会执行到 =(k #t)= ， =call/cc= 就会捕获当前这个连续。

当前的连续就是该lambda表达式，因此当前表达式就变成了 =#t= ，所以就会输出 =#t= 。

#+BEGIN_SRC racket
> (call/cc (lambda (k) (displayln (+ 2 3) (k 'done))))
'done
> (eval ''done)
'done
#+END_SRC

上述例子演示了捕获最外层的 =eval= 函数，等价效果如执行第二个 =eval= 函数。

在LISP中，连续式第一等对象。

从C语言的角度看 =call/cc= 的实现，利用了 <setjump.h> 库里的功能。
主要有 jump_buf 结构，用于存放现场数据， setjump() 保存现场， longjump() 恢复现场。

在LISP的运行时系统（RUN-TIMESYSTEM）中，符号表是自含的（SELF-CONTAINED）。
符号表保存在内存中，并且栈框在内存中是不连续的，这就保证了灵活性。

#+BEGIN_SRC
   +--------+
 ..|........|.. <-- 保存现场
 . |        | .
 . +--------+ .
 . | \ \ \ \| . <-- STACK FRAME
 . |\ \ \ \ | . <- - 表达式：(* 3 7)
 . | \ \ \ \| . <-- 计算结果：21
 . +--------+ .
 . |        | .
 . |        | .
 . +--------+ .
 . | xxxxxx | .
 . | xxxxxx | . <-- STACK FRAME
 . | xxxxxx | . <-- 捕获处，未计算
 . +--------+ .
 . |        | .
 ..|... ....|..
   |        |
#+END_SRC

以捕获 =(+ (* 3 7) (call/cc (lambda (k) (k (/ 8 2)))))= 为例，
如上图所示，在内存中，各个表达式所在的栈框在内存中是不连续的，并且 =(* 3 7)= 会完成计算，
和其他必须的数据一同被拷贝下来，复制到lambda所在的栈框执行。除了已完成计算的部分，其他未计算的部分都会被丢弃。

即：call/cc 后面未计算的部分会被丢弃。

基于LISP的栈不连续，用自含的符号表查询栈的位置，非常灵活。

** PROMISE

SCHEME 默认是应用序，会先把参数算出来。
可以改成正则序，需要的时候再算。

PROMISE（承诺）就能够延迟运算表达式，就像加了层衣服。

#+BEGIN_SRC racket
> (delay (+ 1 100))
#<promise:readline-input:18:0>
> (define bar (delay (+ 1 100)))
> (force bar)
101
#+END_SRC

如上演示，可以通过 =delay= 函数，先对函数进行承诺，可以看到 =delay= 的表达式是个 promise 。
然后可以通过 =force= 函数唤醒表达式，进行计算。

** 求值器的变形

*** STREAM

PROMISE 的一个应用就是 STREAM （流），先承诺后运算也叫LAZY EVALUATION（惰性计算）。

比如：读取文件时，一个一个字节读，就组成一个流，来一个字节处理一次。

流的模型如下：
#+BEGIN_SRC
+--------------------+
| PROMISE            |
|                    |
|    +-----------+   |
|    |EXP        |   |
|    |           |   |
|    | (force p) |   |
|    +-----------+   |
|                    |
+--------------------+
#+END_SRC

外层包装了PROMISE，里面在需要执行的时候使用 =force= 唤醒表达式。
一次一次的处理过程就像太极一样，来回推导。

*** AMB

NON-DETERMINISITIC 意为不确定性计算。
在泛极中，正、常、奇、混四种状态中的混，引出了非确定性计算。

这里面引出 AMBIGUITY OPERATOR 歧义算子。
就像老鼠进入迷宫，老鼠可能成功找到出口，也可能失败。老鼠如何选择路线则是表达式，迷宫则是整个算式的环境。
这就引出四个参数：

- FAILURE 失败的处理
- SUCCESS 成功的处理
- ENV 环境
- EXP 表达式

在每个岔路口选择路线时，EXP和ENV都在变。

在选择失败了后，通过回溯，从新选择新的路线，直到最后成功。除非迷宫没有出口，这是 error 特殊情况。

迷宫问题其实模型就是一个树，如下：

#+BEGIN_SRC
               +-+
               | |   <-- ENTRANCE
               +++
                |
    +-----------------------+
    |           |           |
    v           v           v
   +++         +++         +++
   | |         | |         | |
   +++         +++         +++
    |           |           |
+-------+   +-------+   +-------+
|   |   |   |   |   |   |   |   |
v   v   v   v   v   v   v   v   v
               +++
               | |
               +++
                |
            +-------+
            |   |   |
            v   v   v <-- EXIT
#+END_SRC

比如一个编译器，需要语法检查、语义检查，会一层一层检查下去。

在编译器中有两大算法

- GEN-PATCH 生成-匹配 从上到下
- SHIFT-REDUCTION 移进-规约 从下到上

不确定性计算的模型如下:

#+BEGIN_SRC
+------------+
| ENV        |
|  +-----+   |
|  |EXP  |   |
|  +-----+   |
|            |
+------------+
#+END_SRC

外层是 ENV 整体环境，内层是 EXP 表达式。整体环境和表达式是固定的，但是会根据每次选择的情况选择适合的表达式。

*** LOGIC PROGRAMMING

在前两种变形的基础上引出了 LOGIC PROGRAMMING 逻辑运算。

在BNF（EBNF）范式中，逻辑运算通过断言组织成一棵树。

这里面同样有 SK 、FK ，即成功之后的操作和失败之后的操作。
这些表达式与 LOGIC RULES 逻辑规则 等一起组成了当前逻辑运算的 ENV 。

逻辑运算和上一个变形不同在于，逻辑运算的EXP/ENV都在变化。

逻辑运算中的问题是不确定的，因此需要运用 STREAM （流）将所有的问题枚举出来，一个一个解决。

问题的解决可以通过 AMB （非确定性计算），当成图与图的对比。

该变形的模型如下：
#+BEGIN_SRC
+^-^-^-^-^-^-+
< ENV        >
|  +-^-^-+   |
<  <EXP  >   >
|  +-^-^-+   |
<            >
+-^-^-^-^-^-^+
#+END_SRC

这些求值器的变形是人工智能的基础，只有知道这些理论才能够解决人工智能问题。

** 泛系方法论

泛系方法论是洪老师推崇的方法论，模型为：*PM 1 2 3* ，用来描述项目中的关系。

1. 刻度理论 用来评判事物的尺度，分门别类的处理
2. 形式语言（BNF）建立问题的模型，把问题表达出来
3. 工程化方法 用数学知识对待关系

有三中数学技术，可以等价的解决问题

- 集合论 SET
- 图论 GRAPH
- MATRIX 矩阵

可以看情况，选择合适的工具。

依次通过 1 2 3 点完成关系描述，然后去计算：(EVAL EXP ENV)。

#+AUTHOR: hexingpeng

* Racket 第五课

** 昨日复习

除了前几天学习的内容，还有很多Racket知识没有学习，比如：读写文件、正则表达式、合同等。
这些知识可以在做小项目中学习。

首先学习了计算的本质 -> 学习LISP。

- 最初的语言使用 MACHINE CODE ，ASSEMBLY CODE（汇编）
- Fortune、C语言引入了函数
- C++/JAVA 引入了 TYPE（Class） ，在LISP中引入 CLOSEURE （闭包）

LISP中 CLOSEURE 就是 lambda表达式（λ-exp），define 绑定 key-value （键值对）,cons 函数创造 PAIR （偶对）。
通过 alist （属于PROPER LIST）存储多个偶对，可以构成一个数据库，通过assoc函数可以对其进行操作。

REPL 求值过程中，两个公式：(eval exp env)、(apply proc arg)， apply 用于在求值过程中构造临时表达式。

三种求值器的变形： STREAM 、 回溯 、 逻辑运算。

。。。。。。

** 人工智能导论

人工智能（AI）分为4个部分介绍。

- AI 简介
- AI ETHODOCOGY 人工智能方法论
- LISP与AI的关系
- AI的方向 CASE STUDIES

*** 一 AI 简介

人脑中有10的12次方个神经元，而其中的大部分都没有被开发。

人有八识：

- 五官
- 六识 由记忆组成
- 七识 末那（梵语：manas） 比如：一眼认出老朋友，这是一种模式识别。
- 八识 Alaye 指识之本体，人的潜能，人能调用另一个自己对自己产生认识。

AI指让计算机模拟人的某方面能力。

*** 二 AI ETHODOCOGY

AI问题解题的方法论，分为三个共同特点：

- TARGET 问题的目标
- STATE 求解的过程、状态的变化、问题的转化
- OPERATE 操作

这三点是解决所有AI问题所共同拥有的方面。

举个例子：一个老虎妈妈带着两个虎孩子和一个豹子要过河，豹子不能和虎孩子单独待在一起。
而过河的小船只能坐两只动物，并且只有虎妈妈才能划船，请问，它们该如何过河？

对于这个问题，就是排列组合（COMRINATION AERMMCATION），尝试找到成功的排列。

把人工智能可以分为3个层次，最底层是

- 查找与排序 SEARCH & SORT

但是当基数太大时，要避免组合爆炸。因此组合的复杂度不能是n的阶乘那样，几何增加，可以是n的平方、n的次方。

 查找与排序 中，关键是降低复杂度，对问题空间进行聚类，商化。

第二层是：

- 建立模式 PATTERN 这是AI的核心。

最上层就是应用：

- 应用 如：下棋、证明、机器学习、自然语言、图像识别等。

*** 三 LISP与AI的关系

在 PM 1 2 3 理论中，可以通过集合、图（网）、矩阵来解决问题。

解决问题的模型如下：

#+BEGIN_SRC
+-----------+
|           | <--- 构造解题空间
|  +-----+  |
|  |o o o|<-+----- 问题空间
|  | o o |  |
|  +-----+  |
|           |
+-----------+
#+END_SRC

如果用图，则可以把图进行商化，对子问题进行求解。
商化的子集里是个偏序结构。
问题组成一个TREE树结构，而TREE是LIST的嵌套，所以用LSIP语言来处理AI问题。

*** 四 CAE STUDIES

**** 自然语言处理

对语言的处理不像处理数字那么简单。

比如： I READ A BOOK ==》 (READ I A.BOOK)

BOOK还有一些属性，如：
(BOOK ATTRIBUTES ((LENGTH THICK) (DIFFICUTY DIFF) (TOPIC A)))

这些属性是内节点。

如果这本书是我十年前读过的，那么这个描述是外节点：(READ I 10-YEARS-AGO)。

处理结构如下：

#+BEGIN_SRC
        +
        |
 +---------------+
 |      |        |
 v      v        v
READ    I    BOOK(...)    <-- 内属性（PROPERTY）
                 +
                 |
          +------+---------+   <-- 外属性（PROPERTY）
          |      |         |
          v      v         v
         READ    I    10-YEARS-AGO
#+END_SRC

老的LISP里面有 PLIST 来存储这些数据，而Racket里面没有 PLIST 取而代之的是 ALIST。

**** 图像识别 GRAPH RECONGITION

人眼就像两个 SENSORS （传感器），传递 SIGNALS （信号）给大脑。如果是用计算机处理这些信号，需要 A/D 转换。

比如人识别桌子的边角，大脑里面有对应的模式能够识别。如果用计算机处理，我们需要找到特征值。
可以把它变成线性代数问题，从而转化问题，解决问题。

**** 机器学习 MACHINE LEARNTING

机器学习就是通过给予样本，让计算机自己学习，从中发现规律。

这就是一个不断积累的过程，把经验存放在集合里。
