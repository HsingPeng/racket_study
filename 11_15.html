<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>11_15</title>
<!-- 2016-11-16 三 14:45 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="deep" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">11_15</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Racket第二课 &#x2013; 12个Racket编程要点（上）</a>
<ul>
<li><a href="#sec-1-1">1.1. 要点总览</a></li>
<li><a href="#sec-1-2">1.2. 1. λ-excp</a></li>
<li><a href="#sec-1-3">1.3. 2. INTERNAL DEFINITION</a></li>
<li><a href="#sec-1-4">1.4. 3. SYMBOLIC TABLE</a></li>
<li><a href="#sec-1-5">1.5. 4. FRIST-CLASS OBJECT</a></li>
<li><a href="#sec-1-6">1.6. 5. DISPATCH FUNCTION</a></li>
<li><a href="#sec-1-7">1.7. 6. LET SPECIAL FORM</a></li>
<li><a href="#sec-1-8">1.8. 7. LETREC</a></li>
<li><a href="#sec-1-9">1.9. 8. NAMED LOOP</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Racket第二课 &#x2013; 12个Racket编程要点（上）</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 要点总览</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>λ-excp （lambda表达式）
</li>
<li>INTERNAL DEFINITION （内部定义）
</li>
<li>SYMBOLIC TABLE （符号表）
</li>
<li>FRIST-CLASS OBJECT （函数属于第一等对象）
</li>
<li>DISPATCH FUNCTION （发派函数）
</li>
<li>LET SPECIAL FORM (嵌套闭包)
</li>
<li>LETREC （相互调用）
</li>
<li>NAMED LOOP (尾递归 TAIL-RECURSION)
</li>
<li>LIST PROCESS FUNCTIONS （关联列表 alist，链表 assoc）
</li>
<li>DATABASE (用派发函数 DISPATCH FUNC 操作数据库)
</li>
<li>QUASI-QUOTATION (准引用)
</li>
<li>EVALUATOR(REPL) (高阶算子 HIGHER ORDER OPERATOR)
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 1. λ-excp</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Lambda表达式缩写为λ，lambda表达式就是一个闭包。
</p>

<p>
<b>THUNK</b> ：我们把lambda表达式没有参数这种情况叫做 THUNK ，译作悟空。
</p>

<div class="org-src-container">

<pre class="src src-racket">比如函数
  (λ ()    ;没有参数
    (* 100 100))
</pre>
</div>

<p>
闭包的特性：只有一个口可以进去，参数也通过此传入进去。
</p>

<p>
表达式参数有三种写法。
</p>

<ul class="org-ul">
<li>λ (x y) 两个或多个参数
</li>
<li>λ (x . y) 左边一部分是确定的，如：(x y . z)。后面的会被当做列表
</li>
<li>λ (x) 参数个数不限，会合并成一个列表传入
</li>
</ul>

<p>
示例如下：
</p>
<div class="org-src-container">

<pre class="src src-racket">#lang racket

(define f2 (λ (x . y) (displayln x)))
;结果 1
(f2 1 2 3 4 5)
; (1 2 3)
(f2 '(1 2 3))
; 1
(f2 1 2 3)

(define f3 (λ (x . y) (displayln (car y))))
; 2
(f3 1 2 3)

(define f4 (λ (x . y) (displayln (cdr y))))
; (3)
(f4 1 2 3)

(define f5 (λ (x . y) (displayln (cadr y))))
; 3
(f5 1 2 3 4 5)

(define f6 (λ (x . y) (displayln (cddr y))))
; (4 5)
(f6 1 2 3 4 5)

(define f7 (λ (x . y) (displayln (car x))))
; 1
(f7 '(1 2) 2 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 2. INTERNAL DEFINITION</h3>
<div class="outline-text-3" id="text-1-3">
<p>
内部定义相当于在内部定义一个宪法，在外部用不了。
</p>

<div class="org-src-container">

<pre class="src src-racket">#lang racket

(λ ()
  (define c (λ (x)
	      (* x x)))
  c) ；返回内部函数c

(define foo (lambda () (define f (λ (x) (* x x))) f))

((foo) 4)
</pre>
</div>

<p>
在lambda里定义函数必须在使用该函数之前。
</p>

<p>
函数在LISP中是第一等对象，可被直接返回，另外利用 <code>valus</code> 可以返回多个。
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 3. SYMBOLIC TABLE</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<b>符号表</b> 就如同表格，记录每个对象。 <b>在学习编程语言时一定要建立起符号表的概念，非常重要</b> 。
</p>

<p>
在老的LISP里有如下5个字段：
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">字段</th>
<th scope="col" class="left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">name</td>
<td class="left">名称</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">type</td>
<td class="left">类型</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">value</td>
<td class="left">值</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">plist</td>
<td class="left">有哪些proprity（属性）</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">lambda</td>
<td class="left">λ表达式</td>
</tr>
</tbody>
</table>

<p>
在后来的 scheme 中，没有了 <code>plist</code> 字段，以及 <code>value</code> 和 <code>lamdba</code> 字段合并在一起。
</p>

<p>
在LISP有很多谓词（predicator），如： <code>(number? 100)</code> 。
可以用这些谓词查询类型，就是通过查询符号表 <i>type</i> 。
可以做合同，约定类型，都和字符表有关。
</p>

<p>
<i>name</i> 和 <i>lambda</i> 是形影关系，绑定（bound）在一起。
</p>

<p>
<code>define</code> 的本质是建立偶对，每次 <code>define</code> 都在字符表中插入一条记录，若相同的名称定义了第二次，则会删除原记录，新建一个记录。
</p>

<p>
LISP中有垃圾回收机制，会回收不用的数据。
</p>

<p>
符号表是计算机科学的中心数据结构。
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 4. FRIST-CLASS OBJECT</h3>
<div class="outline-text-3" id="text-1-5">
<p>
第一等对象指：
</p>

<ul class="org-ul">
<li>可以被返回。
</li>
<li>可以被传递。
</li>
<li>可以被命名，作为一个单独的条目存在符号表中。
</li>
<li>可以和其他类型构成数据结构。
</li>
</ul>

<p>
LISP中的函数是第一等对象。
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 5. DISPATCH FUNCTION</h3>
<div class="outline-text-3" id="text-1-6">
<p>
发派函数的核心思想是： <b>对外扫相、对内破执</b> 。
</p>

<p>
意思是从外部提供相应的符号，拿到闭包内用对于的函数做相应的计算。
</p>

<p>
这种方式属于数据提供的编程。
</p>


<p>
比如：
</p>
<div class="org-src-container">

<pre class="src src-racket">#lang racket

;定义发派函数
(define foo
  (λ (s)
  (define (f1) (displayln 'present-flower))
  (define (f2) (displayln 'provide-money))
  (define d (lambda ()
  (cond
    [(equal? s 'beautilful) (f1)]
    [(equal? s 'poor) (f2)])))
  d))

;使用
((foo 'poor))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> 6. LET SPECIAL FORM</h3>
<div class="outline-text-3" id="text-1-7">
<p>
匿名表达式（anonymous）通过 <code>define</code> 操作变成有名函数（named）。
</p>

<div class="org-src-container">

<pre class="src src-racket">; 例1：匿名表达式
((λ (x y)
   (* x y))
 100
 200)

; 例2：通过let绑定多个对象
(let ((x 100)
      (y 200))
      (* x y))

; 例3：嵌套使用
(let ((x 100)
      (y 200))
  (let ((z 300))
    (* x y z)))

; 例4：使用let* 互相绑定，则无需嵌套
(let* ((x 1)
       (y 2)
       (z (* x y)))
  (* x y z))
</pre>
</div>

<p>
<b>注意</b> ：就如 例3 所示，两个闭包嵌套使用。在外层的闭包只可以使用内层的对象，如例子中的z。
但是对于处于同一层次的对象 x y 则不能相互调用，如果x的绑定中用到了y则是错误的。
</p>

<p>
这时可以使用 <code>let*</code> 避免嵌套，如 例4 所示，这时一种语法糖（句法糖）。
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> 7. LETREC</h3>
<div class="outline-text-3" id="text-1-8">
<div class="org-src-container">

<pre class="src src-racket">(define is-even?
  (λ (x)
    (if (= x 0)
	#t
	(is-odd? (- x 1)))))
(define is-odd?
  (λ (x)
    (if (= x 0)
	#f
	(is-even? (- x 1)))))

(is-even? 100)
(is-even? 101)
(is-odd? 9)
</pre>
</div>

<p>
上例为计算是否为偶数和奇数的两个函数，两个函数有相互调用的关系。
我们可以不用一个一个定义两个函数，可以结合在一起同时定义。
</p>

<p>
可以使用 <code>letrec</code> ，如下所示：
</p>
<div class="org-src-container">

<pre class="src src-racket">(letrec ((is-even?
	  (λ (x)
	    (if (= x 0)
		#t
		(is-odd? (- x 1)))))
	 (is-odd?
	  (λ (x)
	    (if (= x 0)
		#f
		(is-even? (- x 1))))))
  (is-even? 100)
  (is-even? 101))
</pre>
</div>

<p>
这里面任意闭包都可以相互调用。
</p>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> 8. NAMED LOOP</h3>
<div class="outline-text-3" id="text-1-9">
<p>
下例展示一种常规的递归方法。
</p>
<div class="org-src-container">

<pre class="src src-racket">; 一种递归 空间效率差
(define
  factorial
  (λ (n)
    (if (= n 0)
	1
	(* n (factorial (- n 1))))))

(factorial 5)
</pre>
</div>

<p>
上例中的递归由于需要嵌套的调用函数，虽然逻辑清晰，但是会导致空间效率特别差。
</p>

<p>
我们可以使用尾递归，在恒定的空间内部运算，没有空间效率损失。
如下例所示，就是尾递归的写法。
</p>

<p>
使用 <code>let</code> 来绑定函数，在内部调用该函数时会回到之前所在位置执行，个人理解类似C语言中的 <code>goto</code> 。
</p>

<div class="org-src-container">

<pre class="src src-racket">;尾递归
(define fac (λ (n)
	      (let loop ([i n]
			 [k 1])
		(if (= i 0)
		    k
		    (loop (- i 1) (* i k))))))
(fac 4)
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: deep</p>
<p class="date">Created: 2016-11-16 三 14:45</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
